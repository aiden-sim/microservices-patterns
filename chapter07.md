# 마이크로서비스 쿼리 구현
- MSA 사용 시, 쿼리 구현 방법도 찾아야 함
- 모놀리식 방식은 비교적 쉽게 쿼리 구현

- MSA 는 다음 두 가지 패턴으로 쿼리 구현
  - API 조합 패턴 : 서비스 클라이언트가 데이터를 가진 여러 서비스를 직접 호출하여 그 결과를 조합하는 패턴. 가장 단순한 방법으로 가급적 이 방법 권장
  - CQRS 패턴 : 쿼리만 지원하는 하나 이상의 뷰 전용 DB를 유지하는 패턴. API 조합 패턴보다 강력한 만큼 구현하기 복잡함 

## 7.1 API 조합 패턴 응용 쿼리

### 7.1.1 findOrder() 쿼리
- MSA 에서 조회 시, 데이터가 여러 서비스에 흩어지게 됨
  - 주문 서비스 : 주문 기본 정보(주문 내역, 주문 상태 등)
  - 주방 서비스 : 음식점 관점의 주문 상태, 픽업 준비까지 예상 소요 시간
  - 배달 서비스 : 주문 배달 상태, 배달 예상 정보, 현재 배달원 위치
  - 회계 서비스 : 주문 지불 상태
    - 클라이언트가 모든 서비스에 요청을 해야 함 

### 7.1.2 API 조합 패턴 개요
- API 조합 패턴은 데이터를 가진 서비스를 호출한 후 그 반환 결과를 조합해서 가져옴
  - API 조합기 : 프로바이더 서비스를 쿼리하여 데이터를 조회
  - 프로바이더 서비스 : 최종 결과로 반환할 데이터의 일부를 갖고 있는 서비스 

- API 조합기는 웹 애플리케이션처럼 웹 페이지에 데이터 랜더링하는 클라이언트일 수도 있고, API 게이트웨이나 프런트엔드를 위한 백엔드 패턴의 변형일 수도 있음

### 7.1.3 API를 조합 패턴으로 findOrder() 쿼리 구현
- REST 끝점 GET /order/{orderId}가 구현된 주문 검색 조합기는 orderId로 네 서비스를 호출한 후 수신한 응답을 조인
- 각 프로바이더 서비스는 애그리거트 하나에 해당하는 응답을 반환하는 REST 끝점을 제공

### 7.1.4 API 조합 설계 이슈
- API 조합 패턴은 두 가지 설계 이슈가 있음
  - 어느 컴포넌트를 쿼리 작업의 API 조합기로 선정할 것인가? (assetManager?)
  - 어떻게 해야 효율적으로 취합 로직을 작성할 것인가?

#### 누가 API 조합기 역할을 맡을 것인가?
- 세 가지 옵션이 있음
  - 1) 서비스 클라이언트를 조합기로 임명
    - 클라이언트가 동일한 LAN에서 실행 중이라면 가장 효율적으로 주문 내역을 조회
    - 클라이언트가 방화벽 외부에 있고 서비스가 위치한 네트워크가 느리다면 실용적이지 않음 
  - 2) 애플리케이션의 외부 API가 구현된 API 게이트웨이를 API 조합기로 사용
    - 쿼리 작업이 애플리케이션의 외부 API 중 일부라면 이 방법 추천 (방화벽 유/무를 말하는 듯?)
    - 모바일 기기 등 방화벽 외부에서 접근하는 클라이언트가 API 호출 한 번으로 여러 서비스의 데이터를 조회할 수 있기 때문에 효율적
  - 3) API 조합기를 스탠드얼론 서비스로 구현 
    - 내부적으로 여러 서비스가 사용하는 쿼리 작업이라면 이 방법 추천

#### API 조합기는 리액티브 프로그래밍 모델을 사용해야 한다
- 분산 시스템을 개발 시, 지연 시간 최소화는 항상 골칫거리
- API 조합기가 프로바이더 서비스를 병렬로 호출해야 시간을 줄일 수 있음
  - 어떤 프로바이더는 순차 호출을 해야 함
- 관리가 용이하고 성능/확장성도 우수한 API 조합기 사용하려면 자바 CompletableFuture, RxJava의 옵저버블 등 사용

### 7.1.5 API 조합 패턴의 장단점
- API 조합 패턴은 다음과 같은 단점도 있음
  - 오버헤드 증가
  - 가용성 저하 우려
  - 데이터 일관성 결여 

#### 오버헤드가 증가한다
- API 조합 패턴은 여러 번 요청하고 여러 DB 쿼리를 실행해야 함. 따라서 그만큼 컴퓨팅/네트워크 리소스가 더 많이 소모되고 운영 비용도 늘어남

#### 가용성이 저하될 우려가 있다
- 하나의 쿼리에 세 서비스(API 조합기 + 둘 이상 프로바이더 서비스)가 반드시 개입되는 구조라 가용성이 낮다. (가동률)
- 가용성을 높이는 두가지 전략
  - 1) 프로바이더 서비스가 불능일 경우 API 조합기가 이전에 캐시한 데이터를 반환
  - 2) API 조합기가 미완성된 데이터를 반환 (나머지 데이터만 반환)

#### 데이터 일관성이 결여된다
- 모놀리식은 한 트랜잭션으로 쿼리 수행 (ACID 보장)
- API 조합 패턴은 여러 DB 대상으로 여러 쿼리 실행하기 때문에 일관되지 않은 데이터 반환될 수 있음

- 효율적으로 구현하기 어려운 쿼리 작업은 CQRS 패턴으로 구현하는 편이 바람직

## 7.2 CQRS 패턴
- CQRS는 하나 이상의 쿼리가 구현된 하나 이상의 뷰 DB를 유지하는 기법
- CQRS는 API 조합 패턴으로는 효율적으로 구현하기 어려운 쿼리 때문에 각광받기 시작함

### 7.2.1 CQRS의 필요성
- API 조합은 MSA의 쿼리 문제를 해결하는 반쪽짜리 솔루션에 불과

#### findOrderHistory() 쿼리 구현
- findOrderHistory()는 다음 매개변수를 받아 소비자의 주문 이력을 조회하는 쿼리
  - consumerId : 소비자 식별자
  - OrderHistoryFilter : 필터 조건. 어느 시점 이후 주문까지 반환할 것인가, 주문 상태, 음식점명 및 메뉴 항목을 검색할 키워드 등

- findOrderHistory()는 findOrder()와 비슷하지만 단건이 아닌, 다건 주문 목록 반환
  - 모든 서비스가 필터/정렬 용도 등의 속성을 보관하는 것이 아니기 때문에 API 조합기로 쿼리 하기 어려움

- API 조합기는 두 가지 방법으로 이 문제를 해결
  - 1) API 조합기로 데이터를 인-메모리 조인
    - 거대한 데이터 뭉치에 사용하면 효율이 떨어짐 
  - 2) API 조합기로 주문 서비스, 주방 서비스에서 데이터를 조회하고, 주문 ID를 이용하여 다른 서비스에 있는 데이터를 요청
    - 해당 서비스가 대량 조회 API를 제공할 경우에만 현실성 있는 방법

#### 어려운 단일 서비스 쿼리: findAvailableRestaurants()
- 하나의 서비스에 국한된 쿼리도 구현하기 어려운 경우
  - 1) 데이터를 가진 서비스에 쿼리 구현하는 것이 부적절한 경우가 있음
  - 2) 서비스 DB가 효율적인 쿼리를 지원하지 않기 때문

- findAvailableRestaurants() 쿼리는 주어진 위치로 배달 가능한 음식점을 검색
- findAvailableRestaurants() 쿼리에서 가장 어려운 부분은 효율적으로 지리 공간 쿼리를 수행하는 작업임
  - 이 쿼리를 어떻게 구현할지 DB의 능력에 좌우됨

- 사용 DB가 지리 공간 기능을 지원하는 경우 비교적 쉽지만, 지원하지 않을 경우 까다로움
  - 음식점 데이터의 레플리카를 저장해야 하는데 항상 최신으로 유지해야 함 

#### 관심사를 분리할 필요성
- 관심사를 어떻게 분리하면 좋을지, 어느 한 서비스에 너무 많은 책임을 부과하지 않으려면 어떻게 해야 할지 문제도 함께 고민해야 함

### 7.2.2 CQRS 개요
- MSA 쿼리 구현 시, 다음 세 가지 난관에 봉착하게 됨
  - API를 조합하여 여러 서비스에 흩어진 데이터를 조회하려면 값비싸고 비효율적인 인-메모리 조인을 해야 함
  - 데이터를 가진 서비스는 필요한 쿼리를 효율적으로 지원하지 않는 DB에 또는 그런 형태로 데이터를 저장
  - 관심사를 분리할 필요가 있다는 것은 데이터를 가진 서비스가 쿼리 작업을 구현할 장소로 적합하지 않다는 뜻 

#### CQRS는 커맨드와 쿼리를 서로 분리한다
- 영속적 데이터 모델과 그것을 사용하는 모듈을 커맨드와 쿼리, 두 개로 나눔
  - 조회(R)는 쿼리쪽 모듈 및 데이터 모델에 구현
    - 다소 복잡한 쿼리 처리 
    - 도메인 이벤트를 구독하고 DB를 업데이트하는 이벤트 핸들러가 있음
  - 생성/수정/삭제(CUD)는 커맨드 쪽 모듈 및 데이터 모델에 구현 
  - 양쪽 데이터 모델 사이의 동기화는 커맨드 쪽에서 발행한 이벤트를 쿼리쪽에서 구독

#### CQRS와 쿼리 전용 서비스
- 쿼리 서비스에는 커맨드 작업이 전혀 없는 오직 쿼리 작업으로만 구성된 API가 있음
- 하나 이상의 다른 서비스가 발행한 이벤트를 구독하여 항상 최신 상태로 유지되는 DB를 쿼리하는 로직이 있음

- 쿼리쪽 서비스는 여러 서비스가 발행한 이벤트를 구독해서 구축된 뷰를 구현하기 좋은 방법
  - 특정 서비스에 종속되지 않기 때문에 스탠드얼론 서비스로 구현

- CQRS는 RDBMS를 기록 시스템으로 활용하면서 텍스트 검색 엔진을 이용하여 텍스트 검색 쿼리를 처리하는 대중적인 접근 방식을 이벤트를 기반으로 일반화한 방법
  - 다만 CQRS는 텍스트 검색 엔진뿐만 아니라 훨씬 다양한 종류의 DB를 활용할 수 있음

- CQRS 쿼리쪽 뷰는 이벤트를 구독해서 거의 실시간으로 업데이트 함

### 7.2.3 CQRS의 장점
- 마이크로서비스 아키텍처에서 쿼리를 효율적으로 구현할 수 있음
- 다양한 쿼리를 효율적으로 구현할 수 있음
- 이벤트 소싱 애플리케이션에 쿼리가 가능함
- 관심사가 더 분리됨

#### 마이크로서비스 아키텍처에서 효율적인 쿼리가 가능하다
- 여러 서비스에서 데이터를 미리 조인해 놓은 CQRS 뷰를 이용하는 것이 간편하고 훨씬 효율적임

#### 다양한 쿼리를 효율적으로 구현할 수 있다
- CQRS 패턴을 이용하면 각 쿼리가 효율적으로 구현된 하나 이상의 뷰를 정의하여 단일 데이터 저장소의 한계를 극복할 수 있음

#### 이벤트 소싱 애플리케이션에서 쿼리가 가능하다
- CQRS 패턴은 하나 이상의 애그리거트 뷰를 정의하고 이벤트 소싱 기반의 애그리거트가 발행한 이벤트 스트림을 구독해서 항상 최신 상태를 유지함
  - 그래서 이벤트 소싱 애플리케이션은 거의 CQRS를 사용함 

#### 관심사가 더 분리된다
- CQRS 패턴은 서비스의 커맨드 쪽, 쿼리 쪽에 각각 알맞은 코드 모듈과 DB 스키마를 별도로 정의
  - 관심사를 분리하면 커맨드/쿼리 양쪽 모두 관리하기 간편해지는 이점 생김

- CQRS를 이용하면 쿼리를 구현한 서비스와 데이터를 소유한 서비스를 달리할 수 있음

### 7.2.4 CQRS의 단점
- 아키텍처가 더 복잡함
- 복제 시차를 처리해야 함

#### 아키텍처가 복잡하다
- 개발자는 뷰를 조회/수정하는 쿼리 서비스를 작성해야 하며, 별도의 데이터 저장소를 관리해아 하는 운영 복잡도 역시 가중됨
- 종류가 다양한 DB를 사용하는 애플리케이션이라면 개발/운영 복잡도가 더 가중됨

#### 복제 시차를 신경 써야 한다
- 커맨드/쿼리 양쪽 뷰 사이의 시차를 처리해야 함
  - 커맨드/쿼리 양쪽 API가 클라이언트에 버전 정보를 전달해서 데이터를 분간할 수 있게 만드는 것 (클라는 최신 데이터를 받을 때까지 쿼리 쪽 뷰를 계속 폴링)
  - 커맨드가 반환한 데이터로 자체 모델을 업데이트

## 7.3 CQRS 뷰 설계
- 이벤트 핸들러 모듈은 이벤트를 구독해서 DB를 업데이트하고, 쿼리 API 모듈은 데이터를 조회 함
- 뷰 모듈을 개발할 때 몇 가지 중요한 설계 결정
  - DB를 선정하고 스키마를 설계
  - 데이터 접근 모듈을 설계할 때 멱등한/동시 업데이트 등 다양한 문제를 고려해야 함
  - 기존 애플리케이션에 새 뷰를 구현하거나 기존 스키마를 바꿀 경우, 뷰를 효율적으로 빌드할 수 있는 수단을 강구
  - 뷰 클라이언트에서 복제 시차를 어떻게 처리할지 결정 

### 7.3.1 뷰 DB 선택
- DB와 데이터 모델의 주목적은 뷰 모듈의 쿼리 작업을 효율적으로 구현

#### SQL 대 NoSQL DB
- RDMS로는 자사 웹 확장 요건을 충족시킬 수 없다는 것을 깨닫고, NoSQL DB가 태동하게 됨
- NoSQL DB는 트랜잭션 기능이 제한적이고 범용적인 쿼리 능력은 없지만, 어떤 유스케이스는 유연한 데이터 모델, 우수한 성능/확장성 등 SQL 기반 DB보다 더 낫음

- 쿼리 쪽 뷰 스토어 참고 306P

#### 업데이트 작업 지원
- 뷰 데이터 모델에서 쿼리 뿐만 아니라 이벤트 핸들러가 실행할 업데이트 작업 역시 효율적으로 구현되어야 함

### 7.3.2 데이터 접근 모듈 설계
- 이벤트 핸들러와 쿼리 API 모듈은 DB에 직접 접근하지 않고, 대신 데이터 접근 객체(DAO) 및 헬퍼 클래스로 구성된 데이터 접근 모듈을 사용

#### 동시성 처리
- 뷰가 여러 종류의 애거리거트가 발행한 이벤트를 구독할 경우, 여러 이벤트 핸들러가 동일한 레코드에 달려들어 업데이트 가능
  - DAO는 동시 업데이트가 서로의 데이터를 덮어 쓰지 않도록 작성되어야 함 

#### 멱등한 이벤트 핸들러
- 이벤트 핸들러가 멱등한 경우, 중복 이벤트를 처리해도 결과가 동일한다면 문제되지 않음
- 중복 이벤트 때문에 부정확한 결과가 나온다면 멱등한 이벤트 핸들러 아님

- 이벤트 핸들러는 반드시 이벤트 ID를 기록하고 데이터 저장소를 원자적으로 업데이트 해야 함
  - SQL DB면, 이벤트 핸들러가 처리 완료한 이벤트를 뷰 업데이트 트랜잭션의 일부로 PROCESSED_EVENTS 테이블에 삽입할 수 있음
  - NoSQL DB면, 이벤트 핸들러는 자신이 업데이트하는 데이터 저장소 '레코드'에 이벤트를 저장해야 함

#### 클라이언트 애플리케이션이 최종 일관된 뷰를 사용할 수 있다
- 커맨드와 쿼리 모듈 API를 이용하면 클라이언트가 비일관성을 감지하게 만들 수 있음
  - 커맨드 쪽 작업에서 이벤트 id가 포함된 토큰을 반환하고, 이 토큰을 쿼리 작업에 전달하면 데이터가 없는 경우 에러 발생 


### 7.3.3 CQRS 뷰 추가 및 업데이트
- CQRS 뷰는 애플리케이션이 살아 있는 동안 계속 추가/수정될 것임
- 새 뷰를 생성하려면 쿼리 쪽 모듈을 개발 하고, 데이터 저장소를 세팅하고, 서비스를 배포
- 기존 뷰를 수정하는 작업도 이벤트 핸들러를 변경한 후 뷰를 재생성

#### 아카이빙된 이벤트를 이용하여 CQRS 뷰 구축
- 메시지 브로커는 메시지를 무기한 보관할 수 없음
- 필요한 이벤트를 메시지 브로커에서 전부 읽기만 해서 뷰를 구축할 수 없고, AWS S3(텐스) 같은 아카이빙된, 더 오래된 이벤트도 필요

#### CQRS 뷰를 단계적으로 구축
- 전체 이벤트를 처리하는 시간/리소스가 점점 증가하는 것도 뷰 생성의 또다른 문제점
- 해결 방법은 2단계 증분 알고리즘
  - 1단계 : 주기적으로 각 애그리거트 인스턴스의 스냅샷을 그 이전의 스냅샷과 이 스냅샷이 생성된 이후 죽 발생한 이벤트를 바탕으로 계산
  - 2단계 : 이렇게 계산된 스냅샷과 그 이후에 발생한 이벤트를 이용하여 뷰를 생성 


## 7.4 CQRS 뷰 구현: AWS DynamoDB 응용
- DynamoDB는 AWS 확장성이 우수한 NoSQL DB
  - DynamoDB의 데이터 모델은 JSON 객체처럼 계층적인 이름-값 쌍이 포함된 테이블로 구성

- 각 모듈 역할
  - OrderHistoryEventHandler : 여러 서비스가 발행한 이벤트를 구독하며 OrderHistoryDAO를 호출
  - OrderHistoryQuery API 모듈 : 앞서 설명한 REST 끝점을 구현
  - OrderHistoryDataAcess : DynamoDB 테이블 및 관련 헬퍼 클래스를 조회/수정하는 메서드가 정의된 OrderHistoryDAO를 포함
  - ftgo-order-history : 주문이 저장된 DynamoDB 테이블

### 7.4.1 OrderHistoryEventHandlers 모듈
- OrderHistoryEventHandlers는 이벤트를 소비해서 DynamoDB 테이블을 업데이트하는 이벤트 핸들러로 구성된 모듈

### 7.4.2 DynamoDB 데이터 모델링 및 쿼리 설계
- DynamoDB 데이터 접근 능력이 RDBMS에 훨씬 못 미치기 때문에 어떻게 저장하면 좋을지 잘 설계해야 함
- 특히 쿼리는 스키마 설계에 결정적인 영향을 끼치므로 다음과 같은 설계 이슈를 검토
  - ftgo-order-history 테이블 설계
  - findOrderHistory 쿼리 전용 인덱스 정의
  - findOrderHistory 쿼리 구현
  - 쿼리 결과 페이지네이션
  - 주문 업데이트
  - 중복 이벤트 감지 

#### ftgo-order-history 테이블 설계
- DynamoDB의 저장 모델은 아이템이 테이블과 인덱스로 구성
- 314P ftgo-order-history 테이블 참조

- DynamoDB 애플리케이션은 테이블 아이템을 기본키로 삽입/수정/조회 함

#### findOrderHistory 쿼리 전용 인덱스 정의
- 첫번째 속성은 파티션 키 : DynamoDB가 Z축 확장할 때 이 키를 보고 아이템의 저장소 파티션을 선택 
- 두번째 속성은 정렬 키 : query() 작업은 주어진 파티션 키를 갖고 있고, 주어진 범위 내의 정렬 키를 갖고 있으면서, 필터 표현식에 맞는 아이템 목록을 주어진 정렬 키로 정렬

- 보조 인덱스를 사용하여 쿼리
  - ex) ftgo-order-history-consumer-id-and-creation-time (consuerId + orderCreationTime) 

#### findOrderHisotry 쿼리 구현
- DynamoDB query() 작업은 정렬 키에 범위 제약을 걸 수 있는 조건 표현식을 지원하므로 쉽게 구현 가능
- 그 밖의 비식별 속성에 해당되는 검색 기준은 불(boolean) 표현식인 필터 표현식을 이용하여 구현 가능

#### 쿼리 결과 페이지네이션
- DynamoDB 쿼리는 반환할 아이템의 최대 개수를 pageSize 매개변수로 지정
- DynamoDB는 위치 기반의 페이지네이션은 지원하지 않기 때문에, 주문 이력 서비스는 클라이언트에 오파크 페이지네이션 토큰을 반환

#### 주문 업데이트
- DynamoDB는 아이템 추가/수정 시 PutItem(), UpdateItem() 제공
  - PutItem() 은 기본키로 찾은 아이템을 생성 또는 대체
  - UpdateItem()은 개별 아이템 속성을 업데이트하고, 필요 시 아이템을 생성하는 작업

#### 중복 이벤트 감지
- UpdateItem() 작업의 조건부 업데이트 매커니즘을 활용하면 중복 이벤트가 아닐 때에만 아이템을 업데이트 가능
  - 속성이 존재하고 그 값이 자신의 ID보다 같거나 작은 이벤트면 중복 이벤트 

### 7.4.3 OrderHistoryDaoDynamoDB 클래스
- OrderHistoryDaoDynamoDB는 ftgo-order-history 테이블의 아이템을 읽고 쓰는 메서드가 구현된 클래스
  - OrderHistoryEventHandler가 업데이트 메서드
  - OrderHistoryQuery API가 쿼리 메서드

#### addOrder() 메서드
- order, sourceEvent 두 매개변수를 받아 ftgo-order-history 테이블에 Order를 추가하는 메서드

#### notePickedUp() 메서드
- DeliveryPickUp 이벤트 핸들러가 호출하는 메서드

#### idempotenUpdate() 메서드
- idempotenUpdate()는 중복 업데이트를 방지하는 UpdateItemSpec에 조건부 표현식을 추가한 후 아이템을 업데이트
  - 중복 이벤트일 경우 updateItem()이 던진 ConditionalCheckFailedExecption 예외를 붙잡아 아무 일도 하지 않음 

#### findOrderHistory() 메서드
- findOrderHistory()는 보조 인덱스 ftgo-order-history-by-consumer-id-and-creation-time 을 이용하여 ftgo-order-history 테이블을 쿼리해서 소비자 주문을 조회

#### 기타
- CQRS 뷰를 구현하려면 DB 선정 문제부터 시작해서 효율적인 조회/수정이 가능한 데이터 모델의 설계, 동시 업데이트 처리 방법, 중복 이벤트를 걸러 내는 문제 등 고민 해야 함
- 동시성을 잘 처리하고 업데이트의 멱등성을 보장해야 하므로 유일하게 DAO만 코드가 다소 복잡

## 7.5 마치며
- 여러 서비스의 데이터를 조회하는 쿼리는 크게 API 조합 패턴과 커맨드 쿼리 책임 분리(CQRS) 패턴으로 구현
- 여러 서비스에서 데이터를 취합하는 API 조합 패턴은 쿼리를 구현하기 가장 간편한 방법이므로 가능하다면 많이 사용하는 것이 좋음
- API 조합 패턴은 쿼리가 조금만 복잡해져도 대량 데이터를 인-메모리 조인해야 하므로 효율이 낮음
- CQRS 패턴은 뷰 전용 DB를 이용하여 쿼리. 기능이 강력한 만큼 구현 복잡도는 비교적 높은 편
- CQRS 뷰 모듈은 중복 이벤트 솎아 내기, 동시 업데이트 처리 기능을 갖추어야 함
- CQRS를 사용하면 한 서비스가 다른 서비스가 소유한 데이터를 반환하는 쿼리 구현도 가능하므로 관심사 분리 관점에서 유리
- 클라이언트는 CQRS 뷰의 최종 일관성을 처리해야 함
