# 트랜잭션 관리 : 사가
- 마이크로서비스 아키텍처에서도 단일 서비스 내부의 트랜잭션은 ACID가 보장하지만, 여러 서비스의 데이터를 업데이트하는 트랜잭션은 구현하기 까다로움
- 분산 트랜잭션 기법은 요즘 잘 안맞음
- 사가를 써야 하는데 ACD(원자성, 일관성, 지속성)만 지원하고 격리가 안되서 영향을 줄일 수 있는 설계 기법을 적용해야 됨
  - 코레오그래피 : 중앙 제어 장치 없이 참여자가 각자 서로 이벤트를 교환하는 방법
  - 오케스트레이션 : 중앙 제어 장치가 참여자가 할 일을 지시하는 방법

## 4.1 마이크로서비스 아키텍처에서의 트랜잭션 관리
- 스프링은 @Transactional만 붙이면 개발자가 간편하게 트랜잭셔널 비즈니스 로직 작성 가능
- 단일 DB를 접근하는 모놀리식 애플리케이션의 트랜잭션 관리는 어렵지 않지만 다중 DB 사용하는 모놀리식이나 MSA는 트랜잭션 관리가 어려움

### 4.1.1 분산 트랜잭션의 필요성
- <img width="638" alt="스크린샷 2022-05-01 오후 2 22 29" src="https://user-images.githubusercontent.com/7076334/166133415-20017fcc-6a58-44e3-b270-35998f4676ad.png"> 
  - 소비자 : 주문 가능한 소비자인지 확인
  - 주방 서비스 : 주문 내역 확인
  - 회계 서비스 : 신용 카드 승인
  - 주문 : 정상적인 경우 주문 생성
    - MSA에서는 일관성을 유지할 수 있는 수단을 강구해야 됨 

### 4.1.2 분산 트랜잭션(2PC)의 문제점
- 스프링에서는 ChainedTransactionManager, JtaTransactionManager 제공
- XA(분산 트랜잭션 관리 표준)는 2단계 커밋을 이용하여 전체 트랜잭션에 대해 커밋 아니면 롤백 보장
  - SQL DB 및 메시지 브로커(일부) 적용 가능

- 문제점
  - NoSQL(MongoDB, 카산드라)과 현대 메시지 브로커(RabbitMQ, 카프카)는 분산 트랜잭션 지원하지 않음
  - 동기 IPC 형태라 가용성이 떨어짐 (메시지 브로커 얘기 하는듯)

### 4.1.3 데이터 일관성 유지 : 사가 패턴
- 사가는 비동기 메시징을 이용하여 편성한 일련의 로컬 트랜잭션 (ACID 형태로 서비스별 데이터를 업데이트)
  - 비동기 메시징은 하나 이상의 참여자가 일시 불능 상태인 경우에도 사가 전체 단계를 실행시킬 수 있다.

- 사가와 ACID 트랜잭션 차이
  - 1) ACID 트랜잭션에 있는 격리성(I)이 사가는 없음
  - 2) 사가는 로컬 트랜잭션마다 변경분을 커밋하므로 보상 트랜잭션을 걸어 롤백을 해야 함 

- 예제 (6개의 로컬 트랜잭션)
  - ![image](https://user-images.githubusercontent.com/7076334/166135421-3d532809-fbc6-41ad-b36d-11cf836b4ce7.png)
    - 1) 주문 서비스: 주문을 APPROVAL_PENDING 상태로 생성합니다.
    - 2) 소비자 서비스: 주문 가능한 소비자인지 확인합니다.
    - 3) 주방 서비스: 주문 내역을 확인하고 티켓을 CREATE_PENDING 상태로 생성합니다.
    - 4) 회계 서비스: 소비자 신용카드를 승인합니다.
    - 5) 주방 서비스: 티켓 상태를 AWAITING_ACCEPTANCE로 변경합니다.
    - 6) 주문 서비스: 주문 상태를 APPROVED로 변경합니다.
      - 로컬 트랜잭션이 완료되면 메시지를 발행하여 다음 사가 단계 트리거
      - 도중에 에러가 발생되면 어떻게 롤백 시킬 수 있을까? 

#### 사가는 보상 트랜잭션으로 변경분을 롤백한다.
- ACID 트랜잭션은 롤백 쉽게 가능. 하지만 사가는 단계마다 로컬 DB에 변경분을 커밋하므로 자동 롤백 불가능
  - 롤백에 대한 보상 트랜잭션을 미리 작성해야 함 


- ![image](https://user-images.githubusercontent.com/7076334/166135674-5d338f56-02f7-4166-a030-cf11ff4028ec.png)
  - 보상은 단계별 로컬 트랜잭션을 역순으로 보상 실행

- 주문 생성 사가의 보상 트랜잭션
  - <img width="629" alt="image" src="https://user-images.githubusercontent.com/7076334/166135776-1d2a0d33-167a-4b46-9bca-cce0ca192d04.png">

    - 읽기 전용 단계나, 항상 성공하는 단계는 보상 트랜잭션이 필요 없음 
    - 1~3 단계 : 보상 트랜잭션 (실패 가능성이 있는 단계 다음 / 응답 기준으로 생각함)
    - 4 단계 : 피봇 트랜잭션 (절대 실패하지 않는 단계 다음 / 최종 종착지로 이해함)
    - 5~6 단계 : 재시도 가능 트랜잭션 (항상 성공) 




## 4.2 사가 편성

## 4.3 비격리 문제 처리

## 4.4 주문 서비스 및 주문 생성 사가 설계


## 느낀점
- 이렇게 또 이론만 늘었다...
- 설명과 그림이 다른 장에 위치해서 보기 힘들다

## 참고
- https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/

- https://supawer0728.github.io/2018/03/22/spring-multi-transaction/
