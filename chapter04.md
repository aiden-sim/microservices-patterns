# 트랜잭션 관리 : 사가
- 마이크로서비스 아키텍처에서도 단일 서비스 내부의 트랜잭션은 ACID가 보장하지만, 여러 서비스의 데이터를 업데이트하는 트랜잭션은 구현하기 까다로움
- 분산 트랜잭션 기법은 요즘 잘 안맞음
- 사가를 써야 하는데 ACD(원자성, 일관성, 지속성)만 지원하고 격리가 안되서 영향을 줄일 수 있는 설계 기법을 적용해야 됨
  - 코레오그래피 : 중앙 제어 장치 없이 참여자가 각자 서로 이벤트를 교환하는 방법
  - 오케스트레이션 : 중앙 제어 장치가 참여자가 할 일을 지시하는 방법

## 4.1 마이크로서비스 아키텍처에서의 트랜잭션 관리
- 스프링은 @Transactional만 붙이면 개발자가 간편하게 트랜잭셔널 비즈니스 로직 작성 가능
- 단일 DB를 접근하는 모놀리식 애플리케이션의 트랜잭션 관리는 어렵지 않지만 다중 DB 사용하는 모놀리식이나 MSA는 트랜잭션 관리가 어려움

### 4.1.1 분산 트랜잭션의 필요성
- <img width="638" alt="스크린샷 2022-05-01 오후 2 22 29" src="https://user-images.githubusercontent.com/7076334/166133415-20017fcc-6a58-44e3-b270-35998f4676ad.png"> 
  - 소비자 : 주문 가능한 소비자인지 확인
  - 주방 서비스 : 주문 내역 확인
  - 회계 서비스 : 신용 카드 승인
  - 주문 : 정상적인 경우 주문 생성
    - MSA에서는 일관성을 유지할 수 있는 수단을 강구해야 됨 

### 4.1.2 분산 트랜잭션(2PC)의 문제점
- 스프링에서는 ChainedTransactionManager, JtaTransactionManager 제공
- XA(분산 트랜잭션 관리 표준)는 2단계 커밋을 이용하여 전체 트랜잭션에 대해 커밋 아니면 롤백 보장
  - SQL DB 및 메시지 브로커(일부) 적용 가능

- 문제점
  - NoSQL(MongoDB, 카산드라)과 현대 메시지 브로커(RabbitMQ, 카프카)는 분산 트랜잭션 지원하지 않음
  - 동기 IPC 형태라 가용성이 떨어짐 (메시지 브로커 얘기 하는듯)

### 4.1.3 데이터 일관성 유지 : 사가 패턴
- 사가는 비동기 메시징을 이용하여 편성한 일련의 로컬 트랜잭션 (ACID 형태로 서비스별 데이터를 업데이트)
  - 비동기 메시징은 하나 이상의 참여자가 일시 불능 상태인 경우에도 사가 전체 단계를 실행시킬 수 있다.

- 사가와 ACID 트랜잭션 차이
  - 1) ACID 트랜잭션에 있는 격리성(I)이 사가는 없음
  - 2) 사가는 로컬 트랜잭션마다 변경분을 커밋하므로 보상 트랜잭션을 걸어 롤백을 해야 함 

- 예제 (6개의 로컬 트랜잭션)
  - ![image](https://user-images.githubusercontent.com/7076334/166135421-3d532809-fbc6-41ad-b36d-11cf836b4ce7.png)
    - 1) 주문 서비스: 주문을 APPROVAL_PENDING 상태로 생성합니다.
    - 2) 소비자 서비스: 주문 가능한 소비자인지 확인합니다.
    - 3) 주방 서비스: 주문 내역을 확인하고 티켓을 CREATE_PENDING 상태로 생성합니다.
    - 4) 회계 서비스: 소비자 신용카드를 승인합니다.
    - 5) 주방 서비스: 티켓 상태를 AWAITING_ACCEPTANCE로 변경합니다.
    - 6) 주문 서비스: 주문 상태를 APPROVED로 변경합니다.
      - 로컬 트랜잭션이 완료되면 메시지를 발행하여 다음 사가 단계 트리거
      - 도중에 에러가 발생되면 어떻게 롤백 시킬 수 있을까? 

#### 사가는 보상 트랜잭션으로 변경분을 롤백한다.
- ACID 트랜잭션은 롤백 쉽게 가능. 하지만 사가는 단계마다 로컬 DB에 변경분을 커밋하므로 자동 롤백 불가능
  - 롤백에 대한 보상 트랜잭션을 미리 작성해야 함 


- ![image](https://user-images.githubusercontent.com/7076334/166135674-5d338f56-02f7-4166-a030-cf11ff4028ec.png)
  - 보상은 단계별 로컬 트랜잭션을 역순으로 보상 실행

- 주문 생성 사가의 보상 트랜잭션
  - <img width="629" alt="image" src="https://user-images.githubusercontent.com/7076334/166135776-1d2a0d33-167a-4b46-9bca-cce0ca192d04.png">

    - 읽기 전용 단계나, 항상 성공하는 단계는 보상 트랜잭션이 필요 없음 
    - 1~3 단계 : 보상 트랜잭션 (실패 가능성이 있는 단계 다음 / 응답 기준으로 생각함)
    - 4 단계 : 피봇 트랜잭션 (절대 실패하지 않는 단계 다음 / 최종 종착지로 이해함)
    - 5~6 단계 : 재시도 가능 트랜잭션 (항상 성공) 


## 4.2 사가 편성
- 사가는 단계를 편성하는 로직으로 구성됨
  - 코레오그래피 : 의사 결정과 순서화를 사가 참여자에게 맡김. 사가 참여자는 주로 이벤트 교환 방식으로 통신
  - 오케스트레이션 : 사가 편성 로직을 사가 오케스트레이터에 중앙화함. 사가 오케스트레이터는 사가 참여자에게 커맨드 메시지를 보내 수행할 작업을 지시

### 4.2.1 코레오그래피 사가
- 사가 참여자가 서로 이벤트를 구독해서 그에 따라 반응

#### 주문 생성 사가 구현 : 코레오그래피 스타일
- 정상 케이스 
  - ![image](https://user-images.githubusercontent.com/7076334/166149979-373210a6-c1f1-4a9e-a458-8f7d7cb2e33e.png)
    - 1.주문 서비스 : 주문을 APPROVAL_PENDING 상태로 생성 → 주문 생성 이벤트를 발행
    - 2.소비자 서비스 : 주문 생성 이벤트 수신 → 소비자가 주문을 할 수 있는지 확인 → 소비자 확인 이벤트를 발행
    - 3.주방 서비스 : 주문 생성 이벤트 수신 → 주문 내역 확인 → 티켓을 CREATE_PENDING 상태로 생성 → 티켓 생성됨 이벤트를 발행합니다.
    - 4.회계 서비스 : 주문 생성 이벤트 수신 → 신용카드 승인을 PENDING 상태로 생성합니다.
    - 5.회계 서비스 : 티켓 생성 및 소비자 확인 이벤트 수신 → 소비자 신용카드 과금 → 신용카드 승인됨 이벤트를 발행합니다.
    - 6.주방 서비스 : 신용카드 승인 이벤트 수신 → 티켓 상태를 AWAITING_ACCEPTANCE로 변경합니다.
    - 7.주문 서비스 : 신용카드 승인됨 이벤트 수신 → 주문 상태를 APPROVED로 변경 → 주문 승인됨 이벤트를 발행합니다.

- 실패 케이스
  - ![image](https://user-images.githubusercontent.com/7076334/166150438-833a4923-c758-4398-b31e-e8f09aff644f.png)
    - 1.주문 서비스: 주문을 APPROVAL_PENDING 상태로 생성 → 주문 생성 이벤트를 발행
    - 2.소비자 서비스: 주문 생성 이벤트 수신 → 소비자가 주문을 할 수 있는지 확인 → 소비자 확인 이벤트를 발행
    - 3.주방 서비스: 주문 생성 이벤트 수신 → 주문 내역 확인 → 티켓 상태를 CREATE_PENDING으로 생성 → 티켓 생성 이벤트를 발행
    - 4.회계 서비스: 주문 생성 이벤트 수신 → 신용카드 승인을 PENDING 상태로 생성
    - 5.회계 서비스: 티켓 생성 및 소비자 확인 이벤트 수신 → 소비자 신용카드 과금 → 신용카드 승인 실패 이벤트를 발행 (여기서 부터 다름)
    - 6.주방 서비스: 신용카드 승인 실패 이벤트 수신 → 티켓 상태를 REJECTED로 변경
    - 7.주문 서비스: 신용카드 승인 실패 이벤트 수신 → 주문 상태를 REJECTED로 변경

- 사가에서 발행/구독 방식으로 통신하면 어떤 문제점이 있을까?

#### 확실한 이벤트 기반 통신
- 코레오그래피 방식의 두 가지 통신 이슈 고려
  - 1) DB를 업데이트하는 작업과 이벤트를 발해앟는 작업은 원자적으로 처리. 앞장에서 본 트랜잭셔널 메시징을 사용해야 함
  - 2) 사가 참여자는 자신이 수신한 이벤트와 자신이 가진 데이터를 연관 지을 수 있어야 함
    - 데이터를 매핑할 수 있도록 다른 사가 참여자가 상관관계 ID가 포함된 이벤트를 발행 

#### 코레오그래피 사가의 장단점
- 장점
  - 단순함 : 비즈니스 객체를 생성, 수정, 삭제할 때 서비스가 이벤트를 발행
  - 느슨한 결합 : 참여자는 이벤트를 구독할 뿐 서로를 직접 알지 못함

- 단점
  - 이해하기 어렵다 : 여러 서비스에 구현 로직이 흩어져 있음(오케스트레이션 사가가 아니기 때문에). 사가의 동작이 어떻게 되는지 이해하기 어려운 편
  - 서비스 간 순환 의존성 : 참여자가 서로 이벤트를 구독하는 특성상, 순환 의존성 발생하기 쉬움(잠재적 설계 취약점)
  - 단단히 결합될 위험성 : 참여자는 자신에게 영향을 미치는 이벤트를 모두 구독해야 함.


### 4.2.2 오케스트레이션 사가
- 사가 오케스트레이터는 커맨드/비동기 응답 상호 작용을 하며 참여자와 통신

#### 주문 생성 사가 구현 : 오케스트레이션 스타일
- 정상 케이스
  - ![image](https://user-images.githubusercontent.com/7076334/166154601-cf36dbaf-9426-4399-9815-63181052fe70.png)
    - 1.사가 오케스트레이터가 소비자 확인 커맨드를 소비자 서비스에 전송합니다.
    - 2.소비자 서비스는 소비자 확인 메시지를 응답합니다.
    - 3.사가 오케스트레이터는 티켓 생성 커맨드를 주방 서비스에 전송합니다.
    - 4.주방 서비스는 티켓 생성 메시지를 응답합니다.
    - 5.사가 오케스트레이터는 신용카드 승인 메시지를 회계 서비스에 전송합니다.
    - 6.회계 서비스는 신용카드 승인됨 메시지를 응답합니다.
    - 7.사가 오케스트레이터는 티켓 승인 커맨드를 주방 서비스에 전송합니다.
    - 8.사가 오케스트레이터는 주문 승인 커맨드를 주문 서비스에 전송합니다.
      - 마지막은 직접 업데이트 해서 승인 처리해도 되지만, 일관성 차원에서 주문 서비스가 다른 참여자인 것처럼 취급 

#### 사가 오케스트레이터를 상태 기계로 모델링
- 상태 기계는 상태와 이벤트에 의해 트리거되는 상태 전이로 구성됨
- 전이가 발생할 때마다 액션이 일어나는데, 사가의 액션은 사가 참여자를 호출하는 작용



#### 사가 오케스트레이션과 트랜잭셔널 메시징

#### 오케스트레이션 사가의 장단점

## 4.3 비격리 문제 처리
- 

## 4.4 주문 서비스 및 주문 생성 사가 설계
-


## 느낀점
- 이렇게 또 이론만 늘었다...
- 설명과 그림이 다른 장에 위치해서 보기 힘들다

## 참고
- https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/

- https://supawer0728.github.io/2018/03/22/spring-multi-transaction/
