# 비즈니스 로직 설계
- 마이크로서비스 아키텍처에서 비즈니스 로직 개발 시, 두 가지 이유로 애그리거트가 요긴함
  -  애그리거트를 사용하면 객체 레퍼런스가 서비스 경계를 넘나들 일이 없음. 객체 참조 대신 기본키를 이용하여 애그리거트가 서로 참조
  -  한 트랜잭션으로 하나의 애그리거트만 생성/수정할 수 있음. 마이크로서비스 트랜잭션 모델의 제약 조건에 잘 맞음

## 5.1 비즈니스 로직 구성 패턴
- 주문 서비스 구성
  - REST API 어댑터 : 비즈니스 로직을 호출하는 REST API가 구현된 인바운드 어댑터
  - OrderCommandHandlers : 메시지 채널에서 들어온 커맨드 메시지를 받아 비즈니스 로직을 호출하는 인바운드 어댑터
  - DB 어댑터 : 비즈니스 로직이 DB 접근을 위해 호출하는 아웃바운드 어댑터
  - 도메인 이벤트 발행 어댑터 : 이벤트를 메시지 브로커에 발행하는 아웃바운드 어댑터 

- 객체 지향 언어를 써서 개발했다고 비즈니스 로직까지 저절로 객체 지향적으로 설계되는 것은 아님
- 비즈니스 로직은 절차적 트랜잭션 스크립트 패턴과 객체 지향적 도메인 모델 패턴, 두 가지 패턴으로 구성

### 5.1.1 비즈니스 로직 설계: 트랜잭션 스크립터 패턴
- 객체 지향 설계를 하지 않고 트랜잭션 스크립트라는 메서드를 작성하여 표현 계층에서 들어온 요청을 처리하는 것
  - 동작이 구현된 클래스와 상태를 보관하는 클래스가 따로 존재

- 단순한 비즈니스 로직에는 아주 잘 맞음

### 5.1.2 비즈니스 로직 설계: 도메인 모델 패턴
- 절차적 접근 방식은 클래스를 어떻게 구성할지 고민하지 않고 단순하게 코딩할 수 있지만, 비즈니스 로직이 복잡해지면 거의 곤리 불가한 상태로 악화됨 (모놀리식이 비대해 지듯)
  - 도메인 모델 패턴을 응용한 객체 지향 설계를 하는 것이 좋음

- 도메인 모델
  - 비즈니스 로직을 상태와 동작을 가진 클래스로 구성된 객체 모델로 구성

- 도메인 모델 패턴을 적용하면 서비스 메서드가 단순해짐
  - 서비스 메서드가 거의 항상 비즈니스 로직이 잔뜩 포함된 영속화 도메인 객체에 위임하기 때문
  - 서비스 메서드는 DB에서 도메인 객체를 로드하고 메서드들 중 하나를 호출 (도메인 클래스는 프라이빗해서 메서드를 통한 간적 접근만 가능)

- 객체 지향 장점
  - 1) 설계를 이해/관리하기 쉬움
  - 2) 객체 지향 설계는 테스트 하기 쉬움
    - 도메인은 외부 의존이 없어 테스트 하기 좋음
  - 3) 객체지향 설계는 잘 알려진 설계 패턴을 응용할 수 있기 때문에 확장하기 쉬움
    - 전략 패턴, 템플릿 메서드 패턴  

### 5.1.3 도메인 주도 설계 개요
- DDD 방식으로 설게하면 각 서비스는 자체 도메인 모델을 가지며, 애플리케이션 전체 도메인 모델의 문제점을 방지할 수 있음
- 하위 도메인과 이와 연관된 경계 컨텍스트 개념은 DDD 패턴의 양대 전략

- DDD에서 흔히 쓰이는 빌딩 블록
  - 엔티티 : 영속성 신원을 가진 객체. 속성 값이 동일해도 엄연히 다른 객체 (JPA @Entity를 붙여 DDD 엔티티를 나타냄)
  - 밸류 객체 : 여러 값을 모아 놓은 객체. 속성 값이 동일한 두 밸류 객체는 서로 바꾸어 사용할 수 있음 (Money, @Embeddable)
    - equals & hashcode (동등성 비교) 
  - 팩토리 : 일반 생성자로 직접 만들기에 복잡한 객체 생성 로직이 구현된 객체 또는 메서드
  - 리포지터리 : 엔티티를 저장하는 DB 접근 로직을 캡슐화한 객체
  - 서비스 : 엔티티, 밸류 객체에 속하지 않은 비즈니스 로직 구현 객체 (얇은)

## 5.2 도메인 모델 설계:DDD 애그리거트 패턴
- 전통적인 객체지향 설계 기반한 도메인 모델은 클래스와 클래스 간 관계를 모아 놓은 것 (보통 패키지로 구성)
  - 클래스가 복잡하게 얽혀 있고, 경계가 분명하지 않다.

### 5.2.1 불분명한 경계 문제
- 개발자가 도메인 객체의 경계를 대략 짐작할 수 밖에 없음
- 경계가 분명하지 않으면 비즈니스 객체를 업데이트할 때 문제가 생길 수 있음

- 메리와 샘 예제가 좀 이해 안감
  - 트랜잭션이 분산되어 있으면 틀어질 수 있다 정도로 이해함 

### 5.2.2 애그리거트는 경계가 분명하다
- 애그리거트는 한 단위로 취급 가능한 경계 내부의 도메인 객체들
  - 하나의 루트 엔티티와 하나 이상의 기타 엔티티 + 밸류 객체로 구성

- 애그리거트는 보통 DB에서 통째로 가져오기 때문에 복잡한 지연 로딩 문제를 신경 쓸 필요가 없음
- 애그리거트를 삭제하면 해당 객체가 DB에서 모두 사라짐

#### 애그리거트는 일관된 경계
- 일부가 아니라 전체 애그리거트를 업데이트하므로 일관성 문제가 해소

#### 애그리거트를 식별하는 일이 관건
- DDD 도메인 모델 설계의 핵심은 애그리거트와 그 경계, 그리고 루트를 식별하는 것

### 5.2.3 애그리거트 규칙

#### 규칙 1: 애그리거트 루트만 참조하라
- 클라이언트는 애그리거트 루트 메서드만 호출해서 애그리거트를 업데이트 할 수 있음
  - 애그리거트는 자신의 불변 값을 강제할 수 있음 

#### 규칙 2: 애그리거트 간 참조는 반드시 기본키를 사용하라
- 애그리거트는 객체 래퍼런스 대신 기본키로 서로 참조해야 됨

- 기본키를 사용하면
  - 애그리거트는 느슨하게 결합되고 애그리거트 간 경계가 분명해지기 때문에 혹여 실수로 다른 애그리거트를 업데이트할 일은 없다.

#### 규칙 3: 하나의 트랜잭션으로 하나의 애그리거트를 생성/수정하라
- 이 규칙을 준수하려면 여러 애그리거트를 생성/수정하는 작업을 구현하기가 조금 복잡해짐 (사가로 해결 가능)

### 5.2.4 애그리거트 입도
- 도메인 모델에서 각 애그리거트의 크기를 결정하는 일은 매우 중요
  - 애그리거트는 작으면 작을수록 좋음
  - 잘게 나누어져 있으면 그만큼 애플리케이션이 동시 처리 가능한 요청 개수가 늘고 확장성이 좋아짐

### 5.2.5 비즈니스 로직 설계: 애그리거트
- 서비스 비즈니스 로직은 대부분 애그리거트로 구성됨. 나머지는 도메인 서비스와 사가에 위치
  - 사가는 로컬 트랜잭션을 오케스트레이션하여 데이터 일관성을 맞춤
  - 인바운드 어댑터는 비즈니스 로직의 진입점인 서비스를 호출
  - 서비스는 리포지터리로 DB에서 애그리거트를 조회하거나, DB에 애그리거트 저장
  - 리포지터리는 DB에 접근하는 아웃바운드 어댑터로 구현

## 5.3 도메인 이벤트 발행
- DDD 맥락에서 도메인 이벤트는 애그리거트에 발생한 사건
- 도메인 이벤트는 도메인 모델에서 클래스로 표현되며, 대부분 어떤 상태 변경을 나타냄

### 5.3.1 변경 이벤트를 발행하는 이유
- 코레오그래피 사가를 이용하여 여러 서비스에 걸쳐 데이터 일관성 유지
- 레플리카를 둔 서비스에 소스 데이터가 변경되었음을 알림 (CQRS)
- 미리 등록된 웹훅이나 메시지 브로커를 통해 비즈니스 프로세스의 다음 단계를 진행하도록 다른 애플리케이션에 알림
- 사용자 브라우저에 웹 소켓 메시지를 보내거나, 일래스틱서치 같은 텍스트 DB를 업데이트 하기 위해 같은 애플리케이션의 다른 컴포넌트에 알림
- 사용자에게 노티
- 애플리케이션이 제대로 작동되고 있는지 도메인 이벤트를 모니터링하면서 확인
- 사용자 행동을 모델링하기 위해 이벤트를 분석

### 5.3.2 도메인 이벤트란 무엇인가?
- 도메인 이벤트는 대부분 이벤트 ID, 타임스탬프 같은 메타데이터도 있음

### 5.3.3 이벤트 강화
- 컨슈머가 서비스를 쿼리해서 애그리거트를 조회하는 것은 오버헤드 유발
  - 컨슈머에 필요한 정ㅈ보를 이벤트가 갖고 다니는 이벤트 강화 기법을 적용 

- 이벤트 강화 기법은 컨슈머를 단순화하는 이점이 있지만, 컨슈머 요건이 바뀌면 이벤트 클래스도 함께 변경해야 되므로 이벤트 클래스의 안정성은 떨어짐

### 5.3.4 도메인 이벤트 식별
- 요즘은 이벤트 스토밍이라는 방법을 많이 사용하는 추세
  - 이벤트 스토밍을 하면 애그리거트와 이벤트로 구성된 이벤트 중심적인 도메인 모델이 완성

- 이벤트 스토밍 3단계
  - 1) 이벤트 브레인스토밍 : 도메인 이벤트를 머리속에서 쥐어 짬. 도메인 모델을 대략 그려 놓은 타임라인에 배치
  - 2) 이벤트 트리거 식별 : 각 이벤트를 일으키는 트리거를 식별 
  - 3) 애그리거트 식별 : 각 커맨드 소비 후 적절한 이벤트를 발생시키는 애그리거트를 식별해서 노란색 점착식 메모지로 표시

### 5.3.5 도메인 이벤트 생성 및 발행

#### 도메인 이벤트 생성
- 개념적으로 도메인 이벤트는 애그리거트가 발행
- 애그리거트와 호출하는 서비스 책임을 분리하는게 좋다. (고수준의 도메인의 저수준에 인프라 관심사에 섞이지 않게)

- 애그리거트는 생성한 이벤트를 두 가지 방법으로 서비스에 반환
  - 1) 애그리거트 메서드 반환값에 이벤트 목록 추가
  - 2) 애그리거트 루트의 특정 필드에 이벤트를 차곡 쌓아두고 서비스가 이벤트를 가져다 발행 


#### 도메인 이벤트를 확실하게 발행하는 방법
- DB 업데이트 트랜잭션의 일부로 이벤트를 OUTBOX 테이블에 삽입하고, 트랜잭션이 커밋되면 이 테이블에 삽입된 이벤트를 메시지 브로커에 발행

### 5.3.6 도메인 이벤트 소비
- 도메인 이벤트는 결국 메시지로 바뀌어 아파치 카프카 같은 메시지 브로커에 발행

## 5.4 주방 서비스 비즈니스 로직
- 인바운드 어댑터
  - REST API : 음식점 점원이 사용하는 UI 호출하는 REST API, KitchenService를 호출하여 Ticket을 생성/수정
  - KitchenServiceCommandHandler : 사가가 호출하는 비동기 요청/응답 API. KitchenService를 호출하여 Ticket을 생성/수정
  - KitchenServiceEventConsumer : RestaurantService가 발행한 이벤트를 구독. KitchenService를 호출하여 Resaurant을 생성/수정

- 아웃바운드 어댑터
  - DB 어댑터 : TicketRepository, ResaurantRepository 인터페이스를 구현하여 DB에 접근
  - DomainEventPublishingAdapter : DomainEventPulbihser 인터페이스를 구현하여 Ticket 도메인 이벤트를 발행

### 5.4.1 Ticket 애그리거트

#### Ticket 클래스 구조

#### Ticket 애그리거트 동작

#### KitchenService 도메인 서비스

#### KitchenServiceCommandHandler 클래스

## 5.5 주문 서비스 비즈니스 로직


## 5.6 마치며


