# 마이크로서비스 테스트 1부
- 수동 테스트 문제점
  - 수동 테스트는 비효율의 극치
  - 테스트가 너무 늦다 

## 9.1 마이크로서비스 아키텍처 테스트 전략

### 9.1.1 테스트 개요
- 테스트 정의
  - 테스트 케이스는 어떤 목표를 달성하기 위해 개발된 테스트 입력, 실행 조건, 기대 결과의 집합 
 
- 테스트 목적은 SUT(System Under Test)의 동작을 확인

#### 자동화 텥스트 작성
- 대부분 JUnit등의 테스트 프레임워크로 작성

- 자동화 테스트는 다음 4단계로 구성
  - 1) 설정(setup) : SUT와 그 디펜던시로 구성된 테스트 픽스처를 초기화
  - 2) 실행(exercise) : SUT를 호출
  - 3) 확인(verify) : 호출 결과 및 SUT 상태를 단언함
  - 4) 정리(teardown) : 필요 시 테스트 픽스처를 깨끗이 정리


#### 목/스텁을 이용한 테스트
- SUT는 대부분 디펜던시를 갖고 있고, 이런 디펜던시 때문에 테스트가 복잡하고 느려짐
  - 해결 방법은 디펜던시를 테스트 더블로 대체

- 테스트 더블은 스텁(stub)과 목(mock) 두 종류
  - 스텁은 SUT에 값을 반환하는 테스트 (then)
  - 목은 SUT가 정호가하게 디펜던시를 호출했는지 확인하는 테스트 (verify)

#### 테스트 종류
- 성능 테스트(performance test), 사용성 테스트(usability test)는 애플리케이션의 서비스 품질 수준을 확인하는 테스트

- 테스트 종류
  - 단위 테스트(unit test) : 서비스의 작은 부분을 테스트
  - 통합 테스트(integration test) : 애플리케이션 서비스가 인프라 서비스 및 타 애플리케이션 서비스와 잘 연동되어 작동하는지 확인
  - 컴포넌트 테스트(component test) : 개별 서비스에 대한 인수 테스트
  - 종단 테스트(end-to-end test) : 전체 애플리케이션에 대한 인수 테스트

#### 테스트 사분면: 테스트 분류 기준
- 두 가지 척도로 테스트를 분류
  - 비즈니스에 관한 테스트인가, 기술에 관한 테스트인가?
    - 비즈니스 관련 테스트는 도메인 전문가의 용어를, 기술에 관한 테스트는 개발자와 구현의 용어를 사용 
  - 테스트를 하는 목적이 프로그래밍을 지원하기 위함인가, 아니면 애플리케이션을 평가하기 위함인가? 
    - 개발자는 프로그래밍 지원 테스트를 일상 업무의 일부로 사용, 애플리케이션 평가 테스트는 개선이 필요한 부분을 식별하는 것이 목표

- 테스트 사분면
  - Q1 : 프로그래밍/기술 관련 지원 - 단위/통합 테스트
  - Q2 : 프로그래밍/비즈니스 관련 지원 - 컴포넌트/종단 간 테스트
  - Q3 : 애플리케이션/비즈니스 관련 평가 - 사용성/예비 테스트
  - Q4 : 애필레키이션/기술 관련 평가 - 비가능(성능 등) 인수 테스트

#### 테스트 피라미드: 테스트 역량을 집중
- 테스트 범위가 늘어나면 실행 시간, 복잡도가 증가하고 신뢰성은 떨어지기 마련

- 테스트 피라미드 (379P)
  - 피라미드 하부는 빠르고 간단하고 미더운 단위 테스트
  - 피라미드 상부는 느리고 복잡하고 취약한 종단 간 테스트
  - 상부로 올라갈 수록 작성하는 테스트 개수는 줄어듬 

### 9.1.2 마이크로서비스 테스트
- MSA에서는 IPC가 중추
  - MSA에서는 팀별로 각자 맡은 서비스를 개발하고 꾸준히 API를 발전시키는 분산 시스템

- 컨슈머는 상호 작용의 성격에 따라 API에 대해 가정
  - REST 클라이언트 -> 서비스 : API 게이트웨이는 서비스로 요청을 라우팅하고 API를 조합함
  - 도메인 이벤트 컨슈머 -> 구독기 : 주문 이력 서비스는 주문 서비스에서 발행된 이벤트를 소비
  - 커맨드 메시지 요청자 -> 응답자 : 주문 서비스는 여러 서비스에 커맨드 메시지를 전송하고 응답을 소비 

- 두 서비스 간의 상호 작용은 계약임
  - 서비스 개발자는 자신이 소비하는 서비스의 API가 안정적인지 확인해야 하며, 자신이 제공하는 서비스의 API를 함부로 바꾸지 않도록 주의

- 종단 간 테스트는 가능한 작성하지 않는 것이 최선 (비즈니스 로직등의 복잡한 고수준 기능까지 호출하는 지경에 이름)
  - 서비스만 따로 떼서 빠르고 간단하게 테스트 하자 (컨슈머 주도 계약 테스트 활용) 

#### 컨슈머 주도 계약 테스트
- REST 끝점의 경우, 컨슈머 계약 테스트는 프로바이더에 다음과 같은 일을 하는 끝점이 구현되었는지 확인
  - 컨슈머가 기대한 HTTP 메서드와 경로인가?
  - 컨슈머가 기대한 헤더를 받는가? (헤더가 있는 경우)
  - 요청 본문을 받는가? (요청 본문이 있는 경우)
  - 컨슈머가 기대한 상태 코드, 헤더, 본문이 포함된 응답을 반환하는가?

- 컨슈머 계약 테스트는 프로바이더의 비즈니스 로직을 체크하는 테스트가 아니다.

- 컨슈머 주고 계약 테스트 방식
  - 컨슈머 개발 팀은 계약 테스트 스위트를 작성 후, 프로바이더의 테스트 스위트에 추가함
  - 이렇게 취합된 테스트 스위트는 주문 서비스 배포 파이프라인으로 실행
  - 컨슈머 계약 테스트가 실패 했다면, 이는 프로듀서 팀 사람들이 API 계약에 안 맞게 고쳤다는 뜻

#### 서비스 테스트: 스프링 클라우드 컨트랙트
- 절 차
  - 1) 하나 이상의 계약을 작성 (API 게이트웨이가 주문 서비스에 전송할 HTTP 요청과 기대되는 HTTP 응답
    - 작성한 계약은 풀 리퀘스트로 주문 서비스 팀에 전달
  - 2) 주문 서비스 팀은 컨슈머 계약 테스트로 주문 서비스를 테스트 (테스트 코드는 스프링 클라우드 컨트랙트에 자동 생성)
  - 3) 주문 서비스 팀은 주문 서비스를 테스트한 계약을 메이븐 저장소로 발행
  - 4) 주문 서비스 팀이 발행한 계약을 이용하여 API 게이트웨이 테스트 작성
 
- 이렇게 테스트 하면 시간이 오래 걸리지 않을까?

#### 컨슈머 계약 테스트: 메시징 API
- 스프링 클라우드 컨트랙트를 이용하면 메시징 기반의 상호 작용도 테스트 가능

### 9.1.3 배포 파이프라인
- 배포 파이프라인은 개발자가 데스크톱에서 작성한 코드를 프로덕션에 반영하는 자동화 프로세스

- 배포 파이프라인 단계
  - 사전-커밋 테스트 단계 : 개발자가 변경분을 커밋하기 전에 단위 테스트를 실행
  - 커밋 테스트 단계 : 서비스 컴파일 후 단위 테스트를 실행하고 정적 코드 분석을 수행
  - 통합 텥스트 단계 : 통합 테스트를 실행
  - 컴포넌트 테스트 단계 : 서비스 컴포넌트 테스트를 실행
  - 배포 단계 : 프로덕션에 서비스를 배포

## 9.2 서비스 단위 테스트 작성
- 단위 테스트는 테스트 피라미드의 최하부에 위치

- 단위 테스트 종류
  - 독립 단위 테스트 : 클래스 디펜던시를 목 객체로 나타내고 클래스를 따로 테스트 함
  - 공동 단위 테스트 : 클래스와 디펜던시를 테스트 함
  
- 어떤 종류 단위 테스트를 할지 클래스의 책임과 아키텍처의 역할마다 다름

- 클래스별로 많이 쓰는 테스트 전략
  - Order처럼 영속성으로 식별 가능한 엔티티는 공동 단위 테스트 수행
  - 값을 모아 놓은 Money 같은 밸류 객체는 공동 단위 테스트 수행
  - CreateOrderSaga 처럼 여러 서비스에 걸쳐 데이터 일관성을 유지하는 사가는 공동 단위 테스트 수행
  - OrderService 처럼 엔티티, 밸류 객체 어디에도 속하지 않는 비즈니스 로직을 구현한 클래스, 즉 도메인 서비스는 독립 단위 테스트를 수행
  - HTTP 요청을 처리하는 컨트롤러는 독립 단위 테스트를 수행
  - 인바운드/아웃바운드 메시징 게이트웨이는 독립 단위 테스트를 수행

### 9.2.1 단위 테스트 작성: 엔티티
- 단위 테스트는 비즈니스 로직을 빈틈없이 테스트
- 실행이 매우 빨라서 컴파일 타임 테스트로 사용 가능

- Order 클래스 예제
  - Order 클래스는 Money 밸류 객체에 의존하므로 Money 클래스도 반드시 함께 테스트 해야 함

### 9.2.2 단위 테스트 작성: 밸류 객체
- 밸류 객체는 불변이고 부수 효과를 걱정할 필요가 없기 때문에 테스트 하기 쉬운편

### 9.2.3 단위 테스트 작성: 사가
- 사가는 사가 참여자에게 커맨드 메시지를 보내고 이들의 응답을 처리하는 영속적 객체

- 사가를 생성하고 사가가 참여자에게 기대한 순서대로 메시지를 전송하는지 확인
- 사가 참여자가 싶래 메시지를 반환해서 사가가 롤백되는 다양한 시나로에 대해서도 테스트

### 9.2.4 단위 테스트 작성: 도메인 서비스
- 서비스 비즈니스 로직은 대부분 엔티티, 밸류 객체, 사가로 구현 하고 나머지는 도메인 서비스 클래스로 구현

- 효과적으로 테스트하는 방법은 리포지터리 및 메시징 클래스 같은 디펜던시를 모킹한 독립 단위 테스트를 수행하는 것

- 독립 단위 테스트 순서
  - 1) 설정 : 서비스 디펜던시의 목 객체를 구성
  - 2) 실행 : 서비스 메서드를 호출
  - 3) 확인 : 서비스 메서드가 올바른 값을 반환하고 디펜던시가 올바르게 호출되었는지 확인 

### 9.2.5 단위 테스트 작성: 컨트롤러
- 컨트롤러를 효과적으로 테스트하려면 서비스와 리포지터리를 모킹한 독립 단위 테스트를 수행하는 방법이 좋음

- 스프링 프레임워크 (mockMVC)를 이용한 테스트가 단위 테스트가 맞을까? (무겁기 때문에 논란이 있을 수도 있음)

### 9.2.6 단위 테스트 작성: 이벤트/메시지 핸들러
- 메시지 어댑터는 컨트롤러와 비슷한 방법으로 단위 테스트 가능
- 테스트별로 메시지 어댑터 인스턴스를 생성하고 메시지를 채널에 전송한 후, 서비스 목이 정확히 호출되었는지 확인
  - 하부 메시징 인프라는 스터빙했기 때문에 어떤 메시지 브로커도 관여하지 않음
