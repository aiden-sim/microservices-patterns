# 마이크로서비스로 리팩터링
- 스트랭글러 애프리케이션
  - 모놀리스 서비스 기능을 하나씩 추출해서 MSA 로 이관 

## 13.1 마이크로서비스 리팩터링 개요

### 13.1.1 모놀리스를 왜 리팩터링하는가?
- 모놀리스 지옥 문제점
  - 느린 전달 : 애플리케이션을 이해, 관리, 테스트하기가 어려워서 개발자 생산성이 떨어짐
  - 버그 투성이 소프트웨어 릴리스 : 테스트성의 결여는 곧 소프트웨어 릴리스가 버그 투성일 때가 많다는 뜻
  - 나쁜 확장성 : 어느 정도 이상은 확장할 수 없거나, 가능하다 해도 비용이 너무 많이 듬 

- 위 같은 현상이 발생되는 이유는 대부분 소프트웨어 개발 프로세스가 낙후되었기 때문

### 13.1.2 모놀리스 옥죄기
- MSA 같은 새로운 아키텍처의 애플리케이션을 개발하기 위해 기존 애플리케이션을 완전히 뜯어고치지 마라 (리스크가 너무 큼)

#### 값을 조기에 자주 검증
- 애플리케이션에서 가치가 큰 부분을 먼저 MSA로 이전
- 단계적 MSA로 리팩터링하면 그 전환 가치를 경영진에게 일찍, 자주 보여줄 수 있음

#### 모놀리스 변경 최소화
- MSA로 전환할 때 모놀리스를 광범위하게 뜯어고치는 행위는 삼가 (시간이 많이 걸리고, 비싸고, 위험)

#### 기술 배포 인프라: 모든 것이 다 필요한 것은 아니다
- 인프라 개발에 필요한 선행 투자는 최소화하는 것이 좋음 (반드시 있어야 할 것은 테스트 자동화 배포 파이프라인 정도)

## 13.2 모놀리스 -> 마이크로서비스 리팩터링 전략
- MSA 교체 3대 전략
  - 1) 새 기능을 서비스로 구현
  - 2) 표현 계층과 백엔드를 분리
  - 3) 기능을 여러 서비스로 추출해서 모놀리스를 분해 

### 13.2.1 새 기능을 서비스로 구현한다
- 이미 거재하고 복잡한 모놀리식 애플리케이션에 새 기능을 추가하지 마라 (관리의 어려움)

#### 새 서비스를 모놀리스에 연계
- 애플리케이션에 통합하는 두 가지 요소
  - API 게이트웨이 : 새 기능의 요청은 새 서비스로, 기존 요청은 모놀리스로 각각 라우팅
  - 통합 글루 코드 : 서비스가 모놀리스 데이터에 접근하고 모놀리스에 구현된 기능을 호출할 수 있게 서비스를 모놀리스에 통합 

#### 새 기능을 서비스로 구현하는 시점
- 서비스로 구현할 수 없는 경우
  - 기능이 너무 적은 경우
  - 기존 모놀리스 코드에 너무 단단히 매여 있는 경우 (성능문제, 일관성 문제) 

### 13.2.2 표현 계층과 백엔드를 분리한다
- 표현 계층을 비즈니스 로직과 데이터 접근 계층에서 분리하면 모놀리식 덩치를 줄일 수 있음
  - 표현 계층 : HTTP 요청을 처리해서 웹 UI에 전달할 HTML 페이지를 생성하는 모듈로 구성
  - 비즈니스 로직 : 엔터프라이즈 애플리케이션 특성상 복잡한 비즈니스 규칙이 구현된 모듈로 구성
  - 데이터 접근 로직 : DB, 메시지 브로커 등 인프라 서비스에 접근하는 모듈로 구성 

### 13.2.3 기능을 여러 서비스로 추출한다
- 모놀리스를 서비스로 추출해야 할 기능은 네 가지
  - API 끝점이 구현된 인바운드 어댑터
  - 도메인 로직
  - DB 접근 로직 등이 구현된 아웃바운드 어댑터
  - 모놀리스의 DB 스키마

- 비즈니스에 가장 중요하고 계속 발전하는 서비스를 가장 먼저 추출하는 것이 좋음

#### 도메인 모델 분리
- 서비스 추출 시, 도메인 모델 추출이 선행되어야 함 (경계에 걸쳐 있는 레퍼런스 제거가 어려움)

- 애그리거트 관점으로 생각하자 (기본키로 서로 참조)

#### DB 리팩터링
- 모놀리스에서 서비스를 추출한다는 것은 데이터도 함께 이전한다는 것을 의미
- 엔티티를 나누려면 해당 DB 테이블도 분리해서 서비스로 이전

#### 변경 범위를 줄이기 위해 데이터를 복제
- DB 리팩터링의 가장 큰 장애물은 전체 DB 클라이언트가 새 스키마를 사용 하도록 변경하는 일
- 전이 기간 동안 원본 스키마를 유지하되, 원본 스키마와 신규 스키마를 동기화하는 트리거를 사용

#### 어떤 서비스를 언제 추출하나
- 추출 시 가장 혜택이 큰 서비스에 집중

- 서비스 추출 순서를 정하는 전략
  - 1) 모놀리스 개발을 사실상 동결하고 요건이 있을 때마다 서비스 추출
  - 2) 서비스 추출 시 기대되는 혜택을 애플리케이션 모듈별로 순위 매김
    - 개발 가속화 : 개발 분량이 많은 경우 서비스로 전환하면 개발 속도 빨라짐
    - 성능, 확장성, 신뢰성 문제 해결 : 애플리케이션 성능, 확장성에 문제가 있거나 미덥지 못한 부분이라면 서비스 전환 가치가 충분
    - 다른 서비스로 추출할 수 있게 만듦 : 한 서비스를 추출하면 모듈 간 디펜던시 때문에 다른 서비스의 추출이 단순해지는 경우도 있음

## 13.3 서비스와 모놀리스 간 협동 설계
- 모놀리스와 협동할때 서비스와 모놀리스 사이의 데이터 일관성을 유지하는 것
  - ACID 트랜잭션 분리 시, 사가를 통해 데이터 일관성도 필요 

### 13.3.1 통합 글루 설계
- 모놀리스에서 서비스를 추출하면 반드시 통합 글루도 개발해야 됨

- REST 형태
  - 서비스는 REST 클라이언트, 모놀리스에는 웹 컨트롤러 위치
- 이벤트 형태
  - 서비스에 이벤트 발행 어댑터, 모놀리스에는 이벤트 핸들러 

#### 통합 글루 API 설계
- 통합 글루 설계 시, 도메인 로직에 어떤 API를 제공할지 결정 (조회, 수정 등)

#### 상호 작용 스타일과 IPC 선택
- 조회
  - 조회 API를 호출하는 것은 단순하지만, 요청 개수가 많아지면 효율이 나빠질 수 있음 (동기 IPC라 가용성이 떨어짐)

  - 데이터 컨슈머가 데이터 레플리카(CQRS)를 유지 (이벤트를 구독해서 이 레플리카를 항상 최신 상태로 유지)
    - 프로바이더를 반복적으로 쿼리하는 오버헤드 감소
    - 레플리카를 관리해야 하는 복잡성은 증가함, 모놀리스가 도메인 이벤트를 발행하도록 수정해야 됨

- 수정
  - 서비스와 모놀리스 모두 데이터 일관성을 유지
  - 서비스와 모놀리스가 이벤추에이트 트램 같은 프레임워크에 구현된 트랜잭셔널 메시징으로 통신

#### 부패-방지 계층 구현
- 기존 모놀리스와 신규 서비스의 도메인 모델 성격이 달라질 수 있기 때문에 서로 소통하려면 DDD에서 말하는 ACL(부패-방지 계층)을 구현해야 함
  - 부패-장지 계층 : 상이한 두 도메인 모델이 서로 상대편을 더럽히지 않도록 변환해 주는 소프트웨어 계층

#### 모놀리스가 도메인 이벤트를 발행/구독하는 방법
- 모놀리스가 도메인 이벤트를 발행하는 방법
  - 서비스가 사용하는 것과 동일한 이벤트 발행 장치를 적용 (특정 엔티티를 변경하는 코드를 모두 찾아 이벤트 발행 API를 끼워 넣어야 한다. 쉽지 않다.)
  - DB 수준에서 도메인 이벤트를 발행 (모놀리스를 변경할 필요 없어서 간편하나, 업데이트 사유를 식별하고 적절한 고수준의 비즈니스 이벤트 발행 어려움)

- 서비스가 발행한 도메인 이벤트는 모놀리스에서 쉽게 구독할 수 있음

### 13.3.2 서비스와 모놀리스에 걸쳐 데이터 일관성 유지
- 모놀리스가 사가에 참여하는것은 코드도 많이 고쳐야 하고, 시간도 엄청 걸림

- 사가 핵심 용어
  - 사가 : 비동기 메시징을 통해 편성되는 일련의 로컬 트랜잭션
  - 보상 트랜잭션 : 로컬 트랜잭션이 업데이트한 내용을 언두하는 트랜잭션
  - 대책 : 사가 간 비격리 문제를 해결하는 데 사용되는 대체 설계 기법
  - 시맨틱 락 : 사가에 의해 업데이트되는 레코드에 플래그를 세팅하는 대책
  - 보상 가능 트랜잭션 : 사가의 후속 트랜잭션 중 하나가 실패할 가능성이 있어서 보상 트랜잭션이 필요한 트랜잭션
  - 피봇 트랜잭션 : 사가의 진행/중단 지점에 위치한 트랜잭션. 피봇 트랜잭션이 성공하면 사가는 완료될 때까지 실행
  - 재시도 가능 트랜잭션 : 피봇 트랜잭션 다음에 나오는 트랜잭션으로 반드시 성공 

#### 보상 트랜잭션을 지원하도록 모놀리스를 고치기는 어렵다
- 모놀리스에서 고쳐야 할 코드가 많다
  - 시간도 많이 걸리고 개발 리소스가 낭비. 모놀리스는 테스트하기 어려운 경우가 많아 위험성이 높음 

#### 사가 적용 시 모놀리스는 보상 트랜잭션을 지원할 필요가 없다
- 보상 트랜잭션을 지원해야 하는 모든 복잡성은 모놀리스보다 테스트하기 좋은 주문 서비스에 집중

#### 서비스 추출 순서를 조정하면 보상 트랜잭션을 모놀리스에 구현하지 않아도 된다
- 서비스 추출 순서를 잘 조정하면 보상 트랜잭션 지원을 위해 모놀리스를 광범위하게 수정하는 수고를 아낄 수 있음

### 13.3.3 인증/인가 처리

#### 모놀리스의 LoginHandler는 USERINFO 쿠키를 세팅한다
- MSA로 전환하려면 LoginHandler가 USERINFO 쿠키도 함께 세팅하도록 변경

#### API 게이트웨이는 USERINFO 쿠키를 Authorization 헤더에 매핑한다
- API 게이트웨이는 USERINFO 쿠키를 검증 이후 이 쿠키를 Authorization 요청 헤더에 넣어 서비스에 전달


## 13.4 새 기능을 서비스로 구현: 배달 실패한 주문 처리


### 13.4.1 배달 지연 서비스 설계

### 13.4.2 배달 지연 서비스를 위한 통합 글루 설계

#### CustomerContactInfoRepository로 고객 연락처 조회

#### 주문/음식점 도메인 이벤트의 발행과 소비


## 13.5 모놀리스 분해: 배달 관리 추출

