# 마이크로서비스로 리팩터링
- 스트랭글러 애프리케이션
  - 모놀리스 서비스 기능을 하나씩 추출해서 MSA 로 이관 

## 13.1 마이크로서비스 리팩터링 개요

### 13.1.1 모놀리스를 왜 리팩터링하는가?
- 모놀리스 지옥 문제점
  - 느린 전달 : 애플리케이션을 이해, 관리, 테스트하기가 어려워서 개발자 생산성이 떨어짐
  - 버그 투성이 소프트웨어 릴리스 : 테스트성의 결여는 곧 소프트웨어 릴리스가 버그 투성일 때가 많다는 뜻
  - 나쁜 확장성 : 어느 정도 이상은 확장할 수 없거나, 가능하다 해도 비용이 너무 많이 듬 

- 위 같은 현상이 발생되는 이유는 대부분 소프트웨어 개발 프로세스가 낙후되었기 때문

### 13.1.2 모놀리스 옥죄기
- MSA 같은 새로운 아키텍처의 애플리케이션을 개발하기 위해 기존 애플리케이션을 완전히 뜯어고치지 마라 (리스크가 너무 큼)

#### 값을 조기에 자주 검증
- 애플리케이션에서 가치가 큰 부분을 먼저 MSA로 이전
- 단계적 MSA로 리팩터링하면 그 전환 가치를 경영진에게 일찍, 자주 보여줄 수 있음

#### 모놀리스 변경 최소화
- MSA로 전환할 때 모놀리스를 광범위하게 뜯어고치는 행위는 삼가 (시간이 많이 걸리고, 비싸고, 위험)

#### 기술 배포 인프라: 모든 것이 다 필요한 것은 아니다
- 인프라 개발에 필요한 선행 투자는 최소화하는 것이 좋음 (반드시 있어야 할 것은 테스트 자동화 배포 파이프라인 정도)

## 13.2 모놀리스 -> 마이크로서비스 리팩터링 전략
- MSA 교체 3대 전략
  - 1) 새 기능을 서비스로 구현
  - 2) 표현 계층과 백엔드를 분리
  - 3) 기능을 여러 서비스로 추출해서 모놀리스를 분해 

### 13.2.1 새 기능을 서비스로 구현한다
- 이미 거재하고 복잡한 모놀리식 애플리케이션에 새 기능을 추가하지 마라 (관리의 어려움)

#### 새 서비스를 모놀리스에 연계
- 애플리케이션에 통합하는 두 가지 요소
  - API 게이트웨이 : 새 기능의 요청은 새 서비스로, 기존 요청은 모놀리스로 각각 라우팅
  - 통합 글루 코드 : 서비스가 모놀리스 데이터에 접근하고 모놀리스에 구현된 기능을 호출할 수 있게 서비스를 모놀리스에 통합 

#### 새 기능을 서비스로 구현하는 시점
- 서비스로 구현할 수 없는 경우
  - 기능이 너무 적은 경우
  - 기존 모놀리스 코드에 너무 단단히 매여 있는 경우 (성능문제, 일관성 문제) 

### 13.2.2 표현 계층과 백엔드를 분리한다
- 표현 계층을 비즈니스 로직과 데이터 접근 계층에서 분리하면 모놀리식 덩치를 줄일 수 있음
  - 표현 계층 : HTTP 요청을 처리해서 웹 UI에 전달할 HTML 페이지를 생성하는 모듈로 구성
  - 비즈니스 로직 : 엔터프라이즈 애플리케이션 특성상 복잡한 비즈니스 규칙이 구현된 모듈로 구성
  - 데이터 접근 로직 : DB, 메시지 브로커 등 인프라 서비스에 접근하는 모듈로 구성 

### 13.2.3 기능을 여러 서비스로 추출한다
- 모놀리스를 서비스로 추출해야 할 기능은 네 가지
  - API 끝점이 구현된 인바운드 어댑터
  - 도메인 로직
  - DB 접근 로직 등이 구현된 아웃바운드 어댑터
  - 모놀리스의 DB 스키마

- 비즈니스에 가장 중요하고 계속 발전하는 서비스를 가장 먼저 추출하는 것이 좋음

#### 도메인 모델 분리
- 서비스 추출 시, 도메인 모델 추출이 선행되어야 함 (경계에 걸쳐 있는 레퍼런스 제거가 어려움)

- 애그리거트 관점으로 생각하자 (기본키로 서로 참조)

#### DB 리팩터링
- 모놀리스에서 서비스를 추출한다는 것은 데이터도 함께 이전한다는 것을 의미
- 엔티티를 나누려면 해당 DB 테이블도 분리해서 서비스로 이전

#### 변경 범위를 줄이기 위해 데이터를 복제
- DB 리팩터링의 가장 큰 장애물은 전체 DB 클라이언트가 새 스키마를 사용 하도록 변경하는 일
- 전이 기간 동안 원본 스키마를 유지하되, 원본 스키마와 신규 스키마를 동기화하는 트리거를 사용

#### 어떤 서비스를 언제 추출하나
- 추출 시 가장 혜택이 큰 서비스에 집중

- 서비스 추출 순서를 정하는 전략
  - 1) 모놀리스 개발을 사실상 동결하고 요건이 있을 때마다 서비스 추출
  - 2) 서비스 추출 시 기대되는 혜택을 애플리케이션 모듈별로 순위 매김
    - 개발 가속화 : 개발 분량이 많은 경우 서비스로 전환하면 개발 속도 빨라짐
    - 성능, 확장성, 신뢰성 문제 해결 : 애플리케이션 성능, 확장성에 문제가 있거나 미덥지 못한 부분이라면 서비스 전환 가치가 충분
    - 다른 서비스로 추출할 수 있게 만듦 : 한 서비스를 추출하면 모듈 간 디펜던시 때문에 다른 서비스의 추출이 단순해지는 경우도 있음

## 13.3 서비스와 모놀리스 간 협동 설계
- 모놀리스와 협동할때 서비스와 모놀리스 사이의 데이터 일관성을 유지하는 것
  - ACID 트랜잭션 분리 시, 사가를 통해 데이터 일관성도 필요 

### 13.3.1 통합 글루 설계
- 모놀리스에서 서비스를 추출하면 반드시 통합 글루도 개발해야 됨

- REST 형태
  - 서비스는 REST 클라이언트, 모놀리스에는 웹 컨트롤러 위치
- 이벤트 형태
  - 서비스에 이벤트 발행 어댑터, 모놀리스에는 이벤트 핸들러 

#### 통합 글루 API 설계
- 통합 글루 설계 시, 도메인 로직에 어떤 API를 제공할지 결정 (조회, 수정 등)

#### 상호 작용 스타일과 IPC 선택
- 조회
  - 조회 API를 호출하는 것은 단순하지만, 요청 개수가 많아지면 효율이 나빠질 수 있음 (동기 IPC라 가용성이 떨어짐)

  - 데이터 컨슈머가 데이터 레플리카(CQRS)를 유지 (이벤트를 구독해서 이 레플리카를 항상 최신 상태로 유지)
    - 프로바이더를 반복적으로 쿼리하는 오버헤드 감소
    - 레플리카를 관리해야 하는 복잡성은 증가함, 모놀리스가 도메인 이벤트를 발행하도록 수정해야 됨

- 수정
  - 서비스와 모놀리스 모두 데이터 일관성을 유지
  - 서비스와 모놀리스가 이벤추에이트 트램 같은 프레임워크에 구현된 트랜잭셔널 메시징으로 통신

#### 부패-방지 계층 구현
- 기존 모놀리스와 신규 서비스의 도메인 모델 성격이 달라질 수 있기 때문에 서로 소통하려면 DDD에서 말하는 ACL(부패-방지 계층)을 구현해야 함
  - 부패-장지 계층 : 상이한 두 도메인 모델이 서로 상대편을 더럽히지 않도록 변환해 주는 소프트웨어 계층

#### 모놀리스가 도메인 이벤트를 발행/구독하는 방법
- 모놀리스가 도메인 이벤트를 발행하는 방법
  - 서비스가 사용하는 것과 동일한 이벤트 발행 장치를 적용 (특정 엔티티를 변경하는 코드를 모두 찾아 이벤트 발행 API를 끼워 넣어야 한다. 쉽지 않다.)
  - DB 수준에서 도메인 이벤트를 발행 (모놀리스를 변경할 필요 없어서 간편하나, 업데이트 사유를 식별하고 적절한 고수준의 비즈니스 이벤트 발행 어려움)

- 서비스가 발행한 도메인 이벤트는 모놀리스에서 쉽게 구독할 수 있음

### 13.3.2 서비스와 모놀리스에 걸쳐 데이터 일관성 유지
- 모놀리스가 사가에 참여하는것은 코드도 많이 고쳐야 하고, 시간도 엄청 걸림

- 사가 핵심 용어
  - 사가 : 비동기 메시징을 통해 편성되는 일련의 로컬 트랜잭션
  - 보상 트랜잭션 : 로컬 트랜잭션이 업데이트한 내용을 언두하는 트랜잭션
  - 대책 : 사가 간 비격리 문제를 해결하는 데 사용되는 대체 설계 기법
  - 시맨틱 락 : 사가에 의해 업데이트되는 레코드에 플래그를 세팅하는 대책
  - 보상 가능 트랜잭션 : 사가의 후속 트랜잭션 중 하나가 실패할 가능성이 있어서 보상 트랜잭션이 필요한 트랜잭션
  - 피봇 트랜잭션 : 사가의 진행/중단 지점에 위치한 트랜잭션. 피봇 트랜잭션이 성공하면 사가는 완료될 때까지 실행
  - 재시도 가능 트랜잭션 : 피봇 트랜잭션 다음에 나오는 트랜잭션으로 반드시 성공 

#### 보상 트랜잭션을 지원하도록 모놀리스를 고치기는 어렵다
- 모놀리스에서 고쳐야 할 코드가 많다
  - 시간도 많이 걸리고 개발 리소스가 낭비. 모놀리스는 테스트하기 어려운 경우가 많아 위험성이 높음 

#### 사가 적용 시 모놀리스는 보상 트랜잭션을 지원할 필요가 없다
- 보상 트랜잭션을 지원해야 하는 모든 복잡성은 모놀리스보다 테스트하기 좋은 주문 서비스에 집중

#### 서비스 추출 순서를 조정하면 보상 트랜잭션을 모놀리스에 구현하지 않아도 된다
- 서비스 추출 순서를 잘 조정하면 보상 트랜잭션 지원을 위해 모놀리스를 광범위하게 수정하는 수고를 아낄 수 있음

### 13.3.3 인증/인가 처리

#### 모놀리스의 LoginHandler는 USERINFO 쿠키를 세팅한다
- MSA로 전환하려면 LoginHandler가 USERINFO 쿠키도 함께 세팅하도록 변경

#### API 게이트웨이는 USERINFO 쿠키를 Authorization 헤더에 매핑한다
- API 게이트웨이는 USERINFO 쿠키를 검증 이후 이 쿠키를 Authorization 요청 헤더에 넣어 서비스에 전달


## 13.4 새 기능을 서비스로 구현: 배달 실패한 주문 처리
- 구현해야 할 새 기능
  - 1) 주문이 제시간에 배달되지 못하면 이 사실을 고객에게 알림
  - 2) 음식점 영업 종료 전에 주문 픽업을 할 수 없어 배달 자체가 불가능한 경우, 이 사실을 고객에게 알림
  - 3) 주문을 제시간에 배달할 수 없을 경우, 고객 서비스 센터에 연락해서 미리 고객에게 보상책을 제시하는 식으로 상황을 해결
  - 4) 배달 통계를 추적
    - 해당 기능들은 신규 서비스에 현하는게 낫다 

### 13.4.1 배달 지연 서비스 설계
- 배달 지연 서비스는 Order, Restaurant 엔티티를 소유하지 않고, 대신 모놀리스 데이터를 복제함
- 고객 연처는 따로 저장하지 않고 모놀리스에 직접 조회

### 13.4.2 배달 지연 서비스를 위한 통합 글루 설계
- 모놀리스는 Order, Restaurant 도메인 이벤트를 발행하고, 배달 지연 서비스는 이벤트를 수신하여 레플리카를 업데이트
- 배달 지연 서비스는 주문을 제 시간에 배달할 수 없는 경우, 고객 연락처를 조회하는 모놀리스의 REST 끝점을 호출해서 해당 고객에게 알림

#### CustomerContactInfoRepository로 고객 연락처 조회
- 고객 연락처를 조회할 일이 비교적 적고 데이터도 작기 때문에 단순하게 API로 호출

#### 주문/음식점 도메인 이벤트의 발행과 소비
- 주문/음식점은 대량의 데이터를 반복적으로 조회 해야 하기 때문에 레플리카로 유지
  - Order, Restaurant 엔티티 중 일부 속성에 해당하는 하위 집합만 저장 

## 13.5 모놀리스 분해: 배달 관리 추출

### 13.5.1 현행 배달 관리 기능
- 배달 관리는 음식점에서 주문을 픽업하여 소비자에게 배달하는 배달원의 스케줄링을 담당
- 개발 노력응ㄹ 최소화하려면 이런 작업들은 모놀리스에 남겨 두고 알고리즘 핵심만 추출하는 것이 좋다.

### 13.5.2 배달 서비스 개요
- 신규 배달 서비스에는 배달 스케줄링, 재스케줄링, 배달 취소 기능을 구현

- 배달 서비스의 아키텍처 구체화하여 도메인 모델을 구체화 시키려면
  - 어떤 동작과 데이터를 배달 서비스로 이전할까?
  - 배달 서비스는 어떤 API를 모놀리스에 표출하는가?
  - 모놀리스는 어떤 API를 배달 서비스에 표출하는가? 

### 13.5.3 배달 서비스의 도메인 모델 설계

#### 배달 관리를 구성할 엔티티/필드 식별
- 배달 서비스 설계 첫번째 단계는 배달 관리를 면밀히 분석하여 어떤 엔티티와 필드가 있는지 식별하는 작업

#### 배달 서비스로 이전할 데이터 결정
- 어떤 엔티티와 필드가 배달 관리에 참여하는지 식별 했으니, 그 중 어떤 엔티티/필드를 서비스로 옮길 것인지 결정할 차례

- 데이터를 서비스로 옮길 때 두 가지 고민 해야 함
  - 1) 서비스는 어떻게 모놀리스에 잔류한 데이터에 접근할 것인가?
  - 2) 모놀리스는 어떻게 서비스로 이전된 데이터에 접근할 것인가? 

#### 배달 서비스 도메인 로직 설계
- 이 서비스의 핵심은 Delivery, Courier 같은 도메인 클래스
- 배달 서비스의 도메인 로직을 개발하려면 모놀리스에서 코드를 풀어야 하고 잡다한 디펜던시를 쪼개야 함

### 13.5.4 배달 서비스의 통합 글루 설계
- 배달 서비스는 배달 관리 API를 갖고 있고, 모놀리스는 Courier 도메인 이벤트를 발행하고,배달 서비스는 Delivery, Courier 도메인 이벤트를 발행

#### 배달 서비스 API 설계
- 배달 서비스는 모놀리스가 배달 스케줄을 잡거나 변경/취소할 수 있는 API를 제공
  - 느슨한 결합을 촉진하고 가용성을 높이는 비동기 메시징을 사용하는 것이 좋음 

- 도메인 이벤트에 의존하면 Order 이벤트가 Delivery에 어떤 영향을 미치는지 배달 서비스가 알고 있어야 한다.
  - 여기서는 도메인 이벤트 보다는 API 사용 

#### 배달 서비스가 모놀리스 데이터에 접근하는 방법
- 배달 서비스는 모놀리스에 있는 배달원의 위치 및 가용성 데이터를 가져와야 함
  - 데이터 양이 클 수도 있고, 반복적으로 조회해야 할 수도 있어서 모놀리스가 Courier 도메인 이벤트를 발행하는 것이 낫다. 

#### 모놀리스가 배달 서비스 데이터에 접근하는 방법
- 모놀리스도 배달 서비스로 이전된 데이터를 읽어야 함.
  - 직접 서비스 쿼리하면 모놀리스 코드를 많이 고쳐야 함.
  - 당분간은 필요한 데이터를 서비스에서 모놀리스로 복제하는게 낫다.

- 배달 서비스가 Courier, Delivery 도메인 이벤트를 발행

### 13.5.5 배달 서비스와 상호 작용할 수 있게 모놀리스를 변경

#### DeliveryService 인터페이스 정의
- 배달 관리 코드를 앞서 정의한 메시지 기반의 API에 해당하는 자바 인터페이스로 캡슐화 (DeliveryService)

#### DeliveryService 인터페이스를 호하록 모놀리스를 리팩터링
- 배달 관리 호출하는 코드를 모놀리스에서 모두 찾아 DeliveryService 인터페이스 사용하도록 변경
  - 이 작업이 모놀리스에서 서비스를 추출하는 가장 어려운 과정 

#### DeliveryService 인터페이스 구현
- 마지막으로 DeliveryServiceImpl 클래스를 스탠드얼론 배달 서비스에 알림 메시지를 보내는 프록시로 교체

- 배달 서비스가 확실히 기대대로 잘 동작하면 모놀리스에서 관리 코드삭제

