# 분해 전략
- 애플리케이션을 기능에 따라 어떻게 여러 서비스로 분해할 것이냐

## 2.1 마이크로서비스 아키텍처란 무엇인가?
- 서비스란 무엇이고, 그 크기는 어느 정도가 적당할까?
- 아키텍처가 중요한 이유는 소프트웨어의 품질 속성, 즉 '~성'으로 끝나는 지표가 아키텍처에 의해 결정되기 때문
- 마이크로서비스 아키텍처는 관리성, 테스트성, 배포성이 높은 애플리케이션을 구축하는 아킥테서 스타일 임


### 2.1.1 소프트웨어 아키텍처의 정의와 중요성
- 아키텍처란 무엇이고 왜 그렇게 중요한 것일까?

#### 소프트웨어 아키텍처의 정의
- 핵심은 애플리케이션 아키텍처가 여러 파트(엘리먼트)로의 분해와 이런 파트 간의 관계(연관성) 라는 것
- 분해가 중요한 이유
  - 업무와 지식을 분리함. 덕분에 전문 지식을 보유한 사람들이 함께 생산적으로 애플리케이션 작업을 할 수 있음
  - 소프트웨어 엘리먼트가 어떻게 상호 작용하는지 밝힘

#### 소프트웨어 아키텍처의 4+1 뷰 모델
- 4+1 모델은 소프트웨어 아키텍처를 바라보는 상이한 4가지 뷰를 정의
  - ![스크린샷 2022-04-10 오후 8 03 29](https://user-images.githubusercontent.com/7076334/162615030-656cb881-5d1d-49a0-bb25-fa9c01e54d25.png)

- 4뷰 외에도 뷰를 구동시키는 시나리오(+1)
  - 각 시나리오는 특정 뷰 내에서 얼마나 다양한 아키텍처 요소가 협동하여 요청을 처리하는지 기술

#### 아키텍처의 중요성
- 애플리케이션 요건
  - 1) 애플리케이션이 해야 할 일을 정의한 기능 요건
    - 유스 케이스나 사용자 스토리 포맷으로 기술하는데, 이 기능 요건과 아키텍처는 거의 무관
  - 2) 이른바 '~성'으로 끝나는 서비스 품질 요건
    - 아키텍처는 이 요건을 충족시킬 수 있게 설계해야 함 (중요)

### 2.1.2 아키텍처 스타일 개요
- 특정 아키텍처 스타일은 엘리먼트(컴포넌트)와 관계(커넥터)의 한정된 팔레트(사용 가능한 범위)를 제공하며, 이를 토대로 애플리케이션 아키텍처의 뷰를 정의할 수 있다.
- 애플리케이션은 대부분 아키텍처 스타일을 조합해서 사용

#### 계층화 아키텍처 스타일
- 소프트웨어 엘리먼트를 계층별로 구성하는전형적인 아키텍처 스타일
- 계층마다 명확히 정의된 역할을 분담하며, 계층 간 디펜던시는 아키텍처로 제한

- 3계층 아키텍처 (논리 뷰 적용 사례)
  - 표현(프레젠테이션) 계층 : 사용자 인터페이스 또는 외부 API가 구현된 계층
  - 비즈니스 로직 계층 : 비즈니스 로직이 구현된 계층
  - 영속화(퍼시스턴스) 계층 : DB 상호 작용 로직이 구현된 계층

- 계층화 아키텍처의 흠
  - 표현 계층이 하나뿐이다 (호출 시스템이 하나 뿐일까?)
  - 영속화 계층이 하나 뿐이다 (상호 작용하는 DB가 하나 뿐일까?)
  - 비즈니스 로직 계층을 영속화 계층에 의존하는 형태로 정의한다. (이런 디펜던시 때문에 DB 없이 비즈니스 로직을 테스트 하는 것은 불가능)

#### 육각형 아키텍처 스타일
- 육각형 아키텍처는 논리 뷰를 비즈니스 로직 중심으로 구성하는 계층화 아키텍처 스타일의 대안
- ![스크린샷 2022-04-10 오후 8 39 45](https://user-images.githubusercontent.com/7076334/162616289-d524e104-f383-42b0-9d11-6cdf5040862b.png)
  - 육각형 아키텍처의 가장 큰 장점은 비즈니스 로직에 있던 표현/데이터 접근 로직이 어댑터와 분리되었기 때문에 비즈니스 로직이 표현/데이터 접근 로직 어디에도 의존하지 않는다는 점
  - 이렇게 분리하면 비즈니스 로직만 따로 테스트하기 쉽고, 현대 애플리케이션 아키텍처를 좀 더 정확하게 반영할 수 있음

### 2.1.3 마이크로서비스 아키텍처는 일종의 아키텍처 스타일이다
- 모놀리식
  - 모놀리식 아키텍처는 구현 뷰를 단일 컴포넌트(하나의 실행 파일이나 WAR 파일)로 구성한 아키텍처 스타일
  - 육각형 아키텍처 방식으로 구성한 논리 뷰를 가질 수 있음

- 마이크로서비스 (76P)
  - 일종의 아키텍터 스타일로 구현 뷰를 다수의 컴포넌트(여러 실행 파일이나 WAR 파일)로 구성
  - 여기서 컴포넌트는 곧 서비스고, 각 서비스 자체 논리 뷰 아키텍처를 갖고 있음
  - 커넥터는 이런 서비스가 서로 협동할 수 있게 해주는 통신 프로토콜 
  - 마이크로서비스 아키텍처의 핵심 제약 조건은 서비스를 느슨하게 결합 (이 제약을 이해하려면 서비스의 뜻을 정확히 알아야함)

#### 서비스란 무엇인가?
- 서비스는 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트
- 서비스 작업은 크게 커맨트(명령/CUD)와 쿼리(조회/R)로 나눔
- 마이크로서비스 아키텍처는 API를 우회하여 서비스에 접근하는 코드를 작성할 수 없어서 모듈성이 보장됨
- 마이크로서비스는 자체 아키텍처를 갖고 있기 때문에 기술 스택을 독자적으로 구축할 수 있지만, 대부분 육각형 아키텍처 형태를 취함

#### 느슨한 결합
- 서비스는 구현 코드를 감싼 API를 통해서만 상호 작용하므로 클라이언트에 영향을 끼치지 않고 서비스 내부 구현 코드를 바꿀 수 있음
- 느슨하게 결합된 서비스는 유지보수성, 테스트성을 높이고 애플리케이션 개발 시간을 단축하는 효과가 있음
- 서비스의 영속적 데이터는 반드시 프라이빗하게 유지 (DB 스키마 변경 시, 독립적으로 할 수 있음)
- DB를 공유하지 않기 떄문에 여러 서비스끼리 데이터를 쿼리하고 일관성을 유지하는 일이 더 복잡해지는 단점은 있음

#### 공유 라이브러리의 역할
- 마이크로서비스에서 공유 라이브러리를 사용하고픈 유횩에 빠지기 쉬운데, 서비스 코드 중복을 줄이는 것은 좋지만 의도치 않은 서비스간 결합도가 발생할 수 있음
- 공용 라이브러리 요건이 변경되면 관련 서비스를 일히 다시 빌드 배포
  - ex) DspId
- 거의 바뀌지 않는 기능은 라이브러리에 담아 쓴느것이 좋다.
  - ex) Amount?

#### 서비스는 별로 중요하지 않다
- 서비스 크기보단든 작은 팀이 가장 짧은 시간에, 다른 팀과 협동하는 부분은 최소로 하여 개발 가능한 서비스를 설계
- 마이크로서비스 아키텍처는 작고, 느슨하게 결합된 서비스로 애플리케이션을 구성하기 때문에 **유지보수성, 테스트성, 배포성** 등 개발 단계의 품질 속성이 개선됨
- 조직 차원에서 소프트웨어를 더 빨리 개발할 수 있고, 주된 목표는 아니지만 애플리케이션 **확장성**도 향상됨


## 2.2 마이크로서비스 아키텍처 정의
- 애플리케이션 아키텍처 정의 3단계 프로세스
  - ![스크린샷 2022-04-10 오후 9 49 34](https://user-images.githubusercontent.com/7076334/162618985-374c9300-c5ed-41fe-931a-cc1e9675c91e.png)
    - 1단계는 애플리케이션 요건을 핵심 요청으로 추출하는 것 (사용자의 요청 처리)
      - 요청등 최대한 추상화
    - 2단계는 어떻게 여러 서비스로 분해할지 결정
      - 여러 전략 선택 가능 (DDD, 비즈니스 능력에 따라 서비스 정의)
      - 최종 결과는 기술 개념이 아닌 비즈니스 개념 중심으로 이루어진 서비스들
    - 3단계는 서비스별로 API를 정의하는 일
      - 1단계 식별된 시스템 작업을 각 서비스에 배정
      - 여러 서비스가 협동하는 방식을 결정 (IPC, gRPC)

- 분해 과정 장애물
  - 1) 네트워크 지연 (서비스 간 왕복이 잦은 경우)
  - 2) 서비스 간 동시 통신으로 인해 가용성이 떨어지는 문제 (완비형 서비스)
  - 3) 여러 서비스에 걸쳐 데이터 일관성을 지키는 요건 (SAGA)
  - 4) 애플리케이션 도처에 숨어 있는 만능 클래스 (DDD)

### 2.2.1 시스템 작업 식별

#### 고수준 도메인 모델 생성

#### 시스템 작업 정의


### 2.2.2 서비스 정의: 비즈니스 능력 패턴별 분해
#### 비즈니스 능력은 곧 조직이 하는 일이다
#### 비즈니스 능력 식별
#### 비즈니스 능력을 여러 서비스로

### 2.2.3 서비스 정의: 하위 도메인 패턴별 분해

### 2.2.4 분해 지침
#### 단일 책임 원칙
#### 공통 폐쇄 원칙




## 2.3 마치며


