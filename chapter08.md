# 외부 API 패턴

## 8.1 외부 API 설계 이슈
- FTGO 서비스에서 API를 소비하는 네 종류의 클라이언트
  - 브라우저 기반의 일반 소비자 및 음식점 전용 UI, 내부 관리자용 UI가 구현된 웹 애플리케이션
  - 브라우저에서 실행 중인 자바스크립트 애플리케이션
  - 소비자용/배달원용 모바일 앱
  - 서드파티 애플리케이션 

- 클라이언트가 서비스 API를 직접 호출 시, MSA의 단점
  - 서비스 API가 나누어져 있어서 클라이언트가 필요한 데이터를 가져오려면 여러 번 요청해야 함
  - 클라이언트가 서비스 및 API를 알아야 하는 구조라 캡슐화가 되지 않고, 나중에 아키텍처와 API를 바꾸기 어려움 (서버쪽)
  - 클라이언트가 사용하기에 불편하거나 실용적이지 못한 IPC를 서비스에서 사용중인 경우가 있음 

### 8.1.1 API 설계 이슈: FTGO 모바일 클라이언트
- 소비자는 FTGO 모바일 클라이언트에 접속해서 주문하고 이력을 관리

- MSA에서는 주문 데이터가 여러 서비스에 분산되어 있음
  - 주문 서비스 : 기본 주문 정보(주문 내역, 주문 상태 등)
  - 주방 서비스 : 음식점 관점에서 주문 상태 및 픽업 준비를 마칠 예상 시간
  - 배달 서비스 : 주문 배달 상태, 예상 배달 시간, 현재 위치
  - 회계 서비스 : 주문 지불 상태

- 위 방식의 단점은 모바일 클라이언트가 서비스를 직접 호출하는 구조라면, 서비스를 여러 번 호출해서 데이터를 가져와야 됨 (그림 327P)

#### 클라이언트가 요청을 여러 번 전송하기 때문에 UX가 나빠진다
- 인터넷은 LAN보다 대역폭이 훨씬 낮고 지연 시간이 김
- 모바일 개발자가 복잡한 API 조합 코드를 작성할 일이 많아지게 됨
  - 네트워크 요청 횟수가 늘어나 전력 소모도 커짐 (모바일 기기 배터리도 빨리 닳음) 

#### 캡슐화가 되지 않아 프런트엔드 개발자가 백엔드와 맞물려 코드를 변경해야 한다
- 서비스에 관한 지식이 모바일 앱에 포함되어 있으면 서비스 API를 변경하기 아주 곤란해 질 수 있음

#### 클라이언트에 비친화적인 IPC를 사용 중인 클라이언트도 있다
- gRPC, AMQP 같은 메시징 프로토콜은 내부에서는 잘 작동되지만, 모바일 클라이언트가 소비하기 어려운 경우가 많다.
- 방화벽에 친화적이지 않은 프로토콜도 있음

### 8.1.2 API 설계 이슈: 다른 종류의 클라이언트
- 모바일 클라이언트 뿐만 아니라 방화벽 외부에 있는 다른 종류의 클라이언트도 동일한 이슈가 있음

#### 웹 애플리케이션
- 웹 애플리케이션은 방화벽 내부에 위치해서 LAN으로 접근해서 네트워크 이슈 없고, 비친화적인 프로토콜도 접근할 수 있어서 크게 이슈 없다고 이해함

#### 브라우저 기반의 자바스크립트 애플리케이션
- 브라우저 기반의 자바스크립트는 서비스 API 변경 시 업데이트는 쉽지만, 모바일 앱처럼 인터넷을 통해 서비스에 접근하기 때문에 네트워크 지연은 비슷
- 브라우저 기반의 UI는 더 많은 서비스를 조합해야 할 필요가 있어서 서비스 API를 효율적으로 조합하기 어려움

#### 서드파티 애플리케이션
- 서드파티 개발자에게 새 API로 업그레이드하라고 강요할 수 없음 (API 변경 시, 제약으로 이해함)

## 8.2 API 게이트웨이 패턴

### 8.2.1 API 게이트웨이 패턴 개요
- API 게이트웨이는 방화벽 외부의 클라이언트가 애플리케이션에 API 요청을 하는 단일 창구 역할 서비스 (퍼사드 패턴이랑 비슷)
- 퍼사드처럼 API 게이트웨이도 내부 애플리케이션 아키텍처를 캡슐화하고 자신의 클라이언트에 API를 제공
  - 인증, 모니터링, 사용량 제한 등 부수적인 기능도 제공

- API 게이트웨이는 요청 라우팅, API 조합, 프로토콜 변환을 관장

#### 요청 라우팅
- 요청이 들어오면 API 게이트웨이는 라우팅 맵을 찾아보고 어느 서비스로 요청을 보낼지 결정

#### API조합
- API 게이트웨이는 모바일 클라이언트가 요청 한 번으로 필요한 데이터를 조회할 수 있도록 대단위 API를 제공
- 외부는 저성능 네트워크 API 한번만 호출하면 되고, 내부적으로는 고성능 네트워크로 여러개 API 호출해서 조합 (333P)

#### 프로토콜 변환
- 내부에서 gRPC 같은 프로토콜을 사용해도 외부에는 REST API로 제공 가능

#### API 게이트웨이는 클라이언트마다 적합한 API를 제공한다
- API 게이트웨이는 만능 API 제공 가능

#### 엣지 기능 구현
- 애플리케이션 주변에 구현된 요청 처리 기능
  - 인증 : 요청한 클라이언트의 신원을 확인
  - 인가 : 특정 작업을 수행하도록 허가받은 클라이언트인지 확인
  - 사용량 제한 : 특정 클라이언트의 초당 요청 개수를 제한
  - 캐싱 : 서비스 요청 횟수를 줄이고자 응답을 캐시
  - 지표 수집 : 과금 분석용 API 지표 수집
  - 요청 로깅 : 요청을 기록 

- 위와 같은 엣지 기능이 구현된 곳은 세군데
  - 1) 백엔드 서비스
    - 요청이 서비스에 도달하기 전에 미리 애플리케이션이 요청을 인증하는 것이 더 안전함 
  - 2) API 게이트웨이의 상류
  - 3) 전용 엣지 서비스
    - 관심사가 분리되는 큰 장점이 있음  

#### API 게이트웨이 아키텍처
- API 계층에는 독립적인 하나 이상의 API 모듈 위치 (특정 클라이언트용 API 구현)
- 공통 계층에는 엣지 기능 등의 공통 기능이 구현

- API 게이트웨이의 세 API 모듈
  - 모바일 API : FTGO 모바일 클라이언트용 API 구현
  - 브라우저 API : 브라우저에서 실행되는 자바스크립트 애플리케이션용 API 구현
  - 퍼블릭 API : 서드파티 개발자용 API 구현

- API 모듈은 두 가지 방법으로 API 작업을 구현
  - 1) 서비스 API 하나에 직접 매핑되는 API 작업은 해당하는 각각의 서비스 API로 요청
  - 2) API를 조합하는 복잡한 API 작업은 사용자 정의 코드로 구현 


#### API 게이트웨이 소유권 모델
- API 게이트웨이 개발/운영은 누가 담당할까?
  - 1) API 게이트웨이 전담팀을 따로 신설
  - 2) 넷플릭스 권장은, API가 표출된 모듈은 해당 클라이언트 팀(모바일, 웹, 퍼블릭 API팀)이 소유하는 구조가 바람직
    - API 게이트웨이 팀은 공통 모듈 개발 및 게이트웨이 운영 이슈에 집중  

#### 프런트엔드 패턴을 위한 백엔드
- 책임 소재를 명확하기 위해 클라이언트마다 API 게이트웨이를 따로 두는 BFF 패턴 적용
- 공통 기능은 API 게이트웨이 팀이 개발한 공유 라이브러리 사용

- BFF 패턴 장점
  - API 모듈이 서로 격리되어 신뢰성 향상

### 8.2.2 API 게이트웨이의 장단점

#### API 게이트웨이의 장점
- 가장 큰 장점은 애플리케이션의 내부 구조를 캡슐화

#### API 게이트웨이의 단점
- 개발, 배포, 관리를 해야 하는 고가용 컴포넌트가 하나 더 늘어나는 부담을 감수해야 함

### 8.2.3 API 게이트웨이 사례: 넷플릭스
- 현재 이 회사는 기기별 API가 따로 구현된 API 게이트웨이를 사용하며, API 구현 코드는 클라이언트 기기 팀이 소유/개발

### 8.2.4 API 게이트웨이 설계 이슈
- API 게이트웨이 설계 시, 다음과 같은 문제 검토
  - 성능과 확장성
  - 리액티브 프로그래밍 추상체를 이용하여 관리 가능한 코드 작성
  - 부분 실패 처리
  - 애플리케이션 아키텍처에서 선량한 시민 되기 

#### 성능과 확장성
- 동기 I/O
  - 각 네트워크 접속마다 스레드를 하나씩 배정 (모델이 간단하고 잘 작동되는 편)
  - 그러나 동기 I/O는 다소 무거운 OS 스레드를 사용하기 때문에 스레드 개수에 제약을 받고 API 게이트웨이 동시 접속 가능 개수도 제한적

- 비동기 I/O
  - 단일 이벤트 루프 스레드가 I/O 요청을 각 이벤트 핸들러로 디스패치함
  - 논블로킹 I/O는 다중 스레드를 사용하는 오버헤드가 없기 때문에 확장성이 더 좋음
  - 비동기/콜백 기반의 프로그래밍 코드는 이해하고, 디버깅하기 어려운 단점이 있음 

#### 리액티브 프로그래밍 추상체
- 대표적인 JVM 리액티브 추상체들
  - 자바 8 CompletableFutures
  - 리액터 프로젝트 Mono
  - RxJava
  - 스칼라 Future 

#### 부분 실패 처리
- 실패한 요청, 지연 시간이 너무 긴 요청도 적절히 잘 처리해야 됨
  - 회로 차단기 패턴 사용 (3장)

#### 아키텍처의 선량한 시민 되기
- 서비스 디스커버리 패턴(3장)을 이용
- 관측성 패턴(11장)을 활용


## 8.3 API 게이트웨이 구현
- 


## 8.4 마치며
- 
