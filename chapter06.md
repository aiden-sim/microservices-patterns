# 비즈니스 로직 개발:이벤트 소싱

## 6.1 이벤트 소싱 응용 비즈니스 로직 개발
- 이벤트 소싱은 비즈니스 로직을 구성하고 애그리거트를 저장하는 또 다른 방법
- 이벤트는 각 애그리거트의 상태 변화를 나타냄
  - 이벤트를 재연(replay)하여 애그리거트의 현재 상태를 재생성

- 이벤트 소싱 좋은 점
  - 애그리거트 이력이 보존되므로 감사/통제 용도로 사용
  - 도메인 이벤트를 확실하게 발생할 수 있어서 마이크로서비스 아키텍처에 특히 유용

- 이벤트 소싱 단점
  - 어느 정도 학습 비용 필요
  - 이벤트 저장소를 쿼리하기 쉽지 않아 CQRS 패턴 적용해야됨  

### 6.1.1 기존 영속화의 문제점
- 일반적으로 JPA 같은 ORM 프레임워크나 마이바티스등의 저수준 프레임워크를 사용하여 테이블의 로우 단위로 저장
- 다음과 같은 한계가 있음
  - 객체-관계 임피던스 부정합
  - 애그리거트 이력이 없음
  - 감사 로깅우르 구현하기가 번거로움
  - 이벤트 발행 로직이 비즈니스 로직에 추가됨

#### 객체-관계 임피던스 부정합
- 테이블 형태의 관계형 스키마와 관계가 복잡한 리치 도메인 모델의 그래프 구조는 근본적인 개념부터 다름

#### 애그리거트 이력이 없다
- 현재 애그리거트의 상태만 저장
- 애그리거트가 업데이트되면 이전 상태는 사라지고 없음

#### 감사 로깅은 구현하기 힘들고 오류도 자주 발생한다
- 감사 로깅 구현 시, 시간이 걸리는 것도 문제지만, 감사 로깅 코드 및 비즈니스 로직이 계속 분화하기 때문에 버그가 날 가능성도 높음

#### 이벤트 발행 로직이 비즈니스 로직에 추가된다
- 영속화는 도메인 이벤트 발행을 지원하지 않는다.
- 개발자는 이벤트 생성 로직을 추가해야 하는데, 비즈니스 로직과 동기화되지 않을 위험이 있음

### 6.1.2 이벤트 소싱 개요
- 이벤트 소싱은 이벤트를 위주로 비즈니스 로직을 구현하고, 애그리거트를 DB에 일련의 이벤트로 저장하는 기법
- 각 이벤트는 애그리거트의 상태 변화를 나타냄

#### 이벤트를 이용하여 애그리거트를 저장
- 이벤트 소싱은 도메인 이벤트 개념에 기반한 전혀 새로운 방식, 즉 애그리거트를 DB에 있는 이벤트 저장소에 일련의 이벤트로 저장

- 이벤트 재연 3단계
  - 1) 에그리거트의 이벤트를 로드
  - 2) 기본 생성자를 호출하여 애그리거트 인스턴스를 생성
  - 3) 이벤트를 하나씩 순회하며 apply()를 호출

- 함수형 프로그래밍 폴듀 or 리듀스 개념

#### 이벤트는 곧 상태 변화
- 이벤트에 무엇을 전달할지는 컨슈머의 필요에 따라 좌우되지만, 이벤트 소싱에서는 주로 애그리거트에 의해 이벤트 및 그 구조가 결정됨
- 이벤트 소싱에서는 이벤트가 필수이며, 모든 상태 변화를 도메인 이벤트로 나타냄

#### 애그리거트 메서드의 관심사는 오직 이벤트
- 기존에는 커맨드 메서드가 매개변수를 검증한 후 하나 이상의 애그리거트 필드를 업데이트했지만, 이벤트 소싱을 사용하면 커맨드 메서드가 반드시 이벤트를 발생시킴

- 이벤트를 발생시켜 적용하려면 이벤트 소싱은 커맨드 메서드 하나를 둘 이상의 메서드로 리팩터링 해야 함
  - 첫 번째 메서드는 요청을 나타낸 커맨드 객체를 매개변수로 받아 상태를 어떻게 변경해야 할지 결정
    - 매개변수 확인 후 애그리거트 상태는 바꾸지 않고 상태 변경을 나타낸 이벤트 목록을 반환
  - 두 번째 메서드는 정해진 이벤트 타입을 매개변수로 받아 애그리거트를 업데이트

#### 이벤트 소싱 기반의 Order 애그리거트
- 249P

### 6.1.3 동시 업데이트: 낙관적 잠금
- 기존 영속화 메커니즘은 한 트랜잭션이 다른 트랜잭션의 변경을 덮어 쓰지 못하게 낙관적 잠금(버전)으로 처리

- 이벤트 저장소 역시 낙관적 잠금 기법으로 동시 업데이트를 처리할 수 있음
  - 이벤트에 딸려온 버전 정보를 각 애그리거트 인스턴스마다 두고, 애플리케이션이 이벤트를 삽입할 때 이벤트 저장소가 버전 변경 여부를 체크 

### 6.1.4 이벤트 소싱과 이벤트 발행
- 이벤트 소싱 기반의 애플리케이션은, 이벤트를 OUTBOX 테이블에 잠깐 저장했다 지우는 것이 아니라, EVENTS 테이블에 영구 저장하는 중요한 차이점이 있음

#### 이벤트 발행: 폴링
- 이벤트를 EVENTS 테이블에 저장한다고 하면, 발행기에서는 마지막 EVENT_ID를 기록하면 됨

- 하지만 트랜잭션이 이벤트를 발생시키는 순서와 다르게 커밋할 수도 있음
  - 해결 방법은 EVENTS 테이블에 이벤트 발행 여부를 추적할 수 있는 컬럼 추가

#### 이벤트 발행: 트랜잭션 로그 테일링
- 트랜잭션 로그 테일링은 좀 더 정교한 방법
- 이벤트 발행을 확실히 보장하면서도 성능/확장성이 우수함

### 6.1.5 스냅샷으로 성능 개선
- 주기적으로 애그리거트 상태의 스냅샷을 저장하여 성능 개선
  - 최근에 뜬 스냅샷 + 그 이후 발생한 이벤트만 가져오는 방식으로 애그리거트 상태 복원

- 스냅샷을 사용할 경우, 애그리거트 인스턴스는 기본 생성자가 아닌 스냅샷을 이용하여 재생성함

### 6.1.6 멱등한 메시지 처리
- 메시지 브로커가 동일한 메시지를 여러 번 전송할 가능성이 있으므로 메시지 컨슈머는 멱등하게 개발해야 함
- 애그리거트를 생성/수정하는 로컬 ACID 트랜잭션의 일부로 처리한 메시지 ID를 PROCESSED_MESSAGE 테이블에 기록.
  - 이 테이블에 메시지 ID가 있으면 중복 메시지로 판단 

- 구현 방법은 이벤트 저장소가 관계형 DB 인지, NoSQL DB 인지에 따라 다름

#### RDBMS 이벤트 저장소 사용
- 메시지 ID는 PROCESSED_MESSAGE 테이블에, 이벤트는 EVENTS 테이블에 삽입하는 트랜잭션의 일부로 삽입

#### NoSQL 이벤트 저장소 사용
- 트랜잭션 모델이 제한적이라서 메시지를 멱등하게 처리하려면 다른 수단 강구
- 메시지 컨슈머가 메시지 처리 도중 생성된 메시지 ID를 저장
  - 해당 메시지 ID가 애그리거트의 이벤트 있는지 확인하면 중복 메시지 여부 확인 가능 

- 애그리거트가 이벤트를 발생시키지 않을 경우, 오직 메시지 ID를 기록할 목적으로 가짜 이벤트를 저장함
  - 이런 가짜 이벤트는 이벤트 컨슈머가 무시해야 함 

### 6.1.7 도메인 이벤트 발전시키기
- 이벤트 영구 저장은 양날의 검과 같다.
  - 이벤트 구조는 시간이 흐름에 따라 계속 달라지기 때문에 문제가 생길 수 있음

- 애플리케이션은 잠재적으로 여러 버전의 이벤트를 처리해야 함

#### 이벤트 스키마 
- 이벤트 소싱에 기반한 애플리케이션의 스키마는 개념상 다음 세 가지로 구성
  - 하나 이상의 애그리거트로 구성
  - 각 애그리거트가 발생시키는 이벤트를 정의
  - 이벤트 구조를 정의 

#### 업캐스팅을 통한 스키마 변화 관리
- SQL DB는 DB 스키마 변경은 보통 마이그레이션을 이용하여 처리
  - 플라이웨이 등의 툴 사용

- 이벤트 소싱은 이벤트 소싱 프레임워크가 이벤트 저장소에 이벤트를 로드할 때 변경해 줌

### 6.1.8 이벤트 소싱의 장점
- 도메인 이벤트를 확실하게 발행함
- 애그리거트 이력이 보존됨
- O/R 임피던스 불일치 문제를 대부분 방지할 수 있음
- 개발자에게 타임 머신을 제공함

#### 도메인 이벤트를 확실하게 발행
- 이벤트 소싱은 무엇보다 애그리거트 상태가 변경될 때마다 이벤트를 발행
- 이벤트 소싱은 변경을 일으킨 사용자 신원을 이벤트마다 저장하므로 정확한 감사 로그를 제공

#### 애그리거트 이력 보존
- 애그리거트마다 전체 이력이 그대로 보존, 애그리거트의 과거 상태를 임시 쿼리로 쉽게 조회 가능
- 특정 시점의 애그리거트 상태는 그때까지 발생한 이벤트를 폴드하면 알 수 있음

#### O/R 임피던스 불일치 문제를 거의 방지
- 이벤트 소싱은 이벤트를 취합하는 대신 저장

#### 개발자에게 타임 머신 제공
- 이벤트 소싱은 애플리케이션의 모든 일을 기록
- 과거 데이터로 당시에 미처 예상 못했던 요건을 바로 구현 가능

### 6.1.9 이벤트 소싱의 단점
- 새로운 프로그래밍 모델을 배우는 데 시간이 걸림
- 메시징 기반 애플리케이션은 복잡함
- 이벤트를 개량하기 까다로운 편
- 데이터를 삭제하기 어려움
- 이벤트 저장소를 쿼리하기가 만만찮음

#### 새로운 프로그래밍 모델을 배우려면 시간이 걸린다
- 이벤트 소싱은 다소 낯설고 새로운 프로그래밍 모델이라서 초기 학습 시간이 어느정도 필요함

#### 메시징 기반 애플리케이션은 복잡하다
- 멱등하지 않은 이벤트 핸들러는 중복 이벤트를 감지해 걸러 내야 함

#### 이벤트를 발전시키기 어렵다
- 이벤트는 영구 저장되므로 애그리거트는 각 스키마 버전별로 폴드 해야 되는데, 버전 마다 분기 처리 하는 코드로 도배될 수 있음
  - 해결법은 이벤트를 이벤트 저장소에서 가져올 때 최신 버전으로 업그레이드 

#### 데이터를 삭제하기 어렵다
- 이벤트를 삭제하지 않고 사용자의 개인 정보를 망각하기 위해서는 암호화를 사용
- 이메일 주소 같은 사용자 개인 정보를 애그리거트 ID로 사용할 경우 가명화 기법을 사용 (이메일 주소를 UUID 토큰으로 변경)

#### 이벤트 저장소를 쿼리하기 어렵다
- 쿼리 문이 중첩되고 매우 복잡하고 비효율적이 될 수 있다.

## 6.2 이벤트 저장소 구현
- 이벤트 소싱 애플리케이션은 이벤트 저장소에 이벤트를 저장함
- 이벤트 저장소는 DB와 메시지 브로커를 합한 것

- 전용 이벤트 저장소
  - 이벤트 스토어 : 닷넷 기반 오픈 소스 이벤트 저장소
  - 라곰 : 타입세이프가 전신인 라이트벤드 사가 개발한 마이크로서비스 프레임워크
  - 액손 : 이벤트 소싱 및 CQRS를 사용하는 이벤트 주도형 애플리케이션을 위한 오픈 소스 자바 프레임워크
  - 이벤추에이트 : 글쓴이가 창업한 스타트업 회사 

### 6.2.1 이벤추에이트 로컬 이벤트 저장소의 작동 원리
- 이벤트는 MySQL 등의 DB에 저장
- 애플리케이션은 애그리거트 이벤트를 기본키로 조회/삽입하고, 아파치 카프카 등의 메시지 브로커에서 이벤트를 가져와 소비
- 트랜잭션 로그 테일링 장치는 끊임없이 DB에서 메시지 브로커로 이벤트를 나름


#### 이벤추에이트 로컬의 이벤트 DB 스키마
- 이벤트 DB는 세 테이블로 구성
  - events : 이벤트를 저장
    - triggering_event는 중복 이벤트/메시지를 발견하는 용도의 컬럼 
  - entities : 엔티티당 로우 하나
    - 엔티티별 현재 버전을 저장. 낙관적 잠금을 구현하는 용도로 사용 
  - snapshots : 스냅샷을 저장
    - 엔티티별 스냅샷을 저장하는 테이블

#### 이벤추에이트 로컬의 이벤트 브로커를 구독하여 이벤트를 소비
- 서비스는 아파치 카프카로 구현된 이벤트 브로커를 구독해서 이벤트를 소비
- 이벤트 브로커에는 애그리거트 종류마다 토픽이 있음
  - 토픽은 파티셔닝된 메시지 채널이라서, 컨슈머는 메시지 순서를 유지한 상태로 수평 확장 가능 

#### 이벤추에이트 로컬 이벤트 릴레이가 이벤트를 DB에서 브로커로 전파
- 이벤트 릴레이는 이벤트 DB에 삽입된 이벤트를 이벤트 브로커로 전파
  - 가능한 트랜잭션 로그 테일링을 이용하고 다른 DB를 폴링하기도 함

- 이벤트 릴레이는 스탠드얼론 프로세스로 배포 됨

### 6.2.2 자바용 이벤추에이트 클라이언트 프레임워크
- 이벤추에이트 클라이언트는 이벤추에이트 로컬 이벤트 저장소를 사용하는 이벤트 소싱 애플리케이션의 개발 프레임워크임

#### 애그리거트 정의: ReflectiveMutableCommandProcessingAggregate 클래스
- 커맨드는 process()에, 이벤트는 apply()에 각각 디스패치 됨

#### 애그리거트 커맨드 정의
- 애그리거트의 커맨드 클래스는 주어진 애그리거트의 기초 인터페이스를 상속해야 함

#### 도메인 이벤트 정의
- 애그리거트의 이벤트 클래스는 메서드가 하나도 없는 마커 인터페이스 Event를 상속함

#### AggregateRepository 클래스로 애그리거트 생성, 검색, 수정
- AggregateRepository는 다음 메서드가 오버로드 되어 있음
  - save() : 애그리거트를 생성
  - find() : 애그리거트를 검색
  - update() : 애그리거트를 수정

- save()
  - 1) 기본 생성자로 애그리거트 인스턴스를 만듬
  - 2) process()를 호출하여 커맨드를 처리함
  - 3) apply()를 호출하여 생성된 이벤트를 적용
  - 4) 생성된 이벤트를 이벤트 저장소에 저장

- update()
  - 1) 이벤트 저장소에서 애그리거트를 조회
  - 2) process()를 호출하여 커맨드를 처리
  - 3) apply()를 호출하여 생성된 이벤트를 적용
  - 4) 생성된 이벤트를 이벤트 저장소에 저장 

#### 도메인 이벤트 구독
- 이벤추에이트 클라이언트 프레임워크는 이벤트 핸들러 작성에 필요한 API도 제공

## 6.3 사가와 이벤트 소싱을 접목
- 이벤트 소싱에서는 코레오그래피 사가를 쉽게 이용할 수 있음.
- 이벤트 소싱 기반의 비즈니스 로직을 오케스트레이션 기반의 사가에 연계하는 일은 훨씬 어려움
  - 이벤트 저장소의 트랜잭션 개념이 상당히 제한적이기 때문

- 이벤트 저장소를 사용하는 애플리케이션은 애그리거트 하나만 생성/수정하고 결과 이벤트를 발생할 수 있는데, 사가의 각 단계는 다음과 같이 원자적으로 수행되어야 하는 액션들로 구성 됨
  - 사가 생성 : 사가를 시작한 서비스는 원자적으로 애그리거트를 생성/수정하고 사가 오케스트레이터를 생성해야 함
  - 사가 오케스트레이션 : 사가 오케스트레이터는 원자적으로 응답을 소비하고, 자신의 상태를 업데이트 한 후 커맨드 메시지를 전송해야 함
  - 사가 참여자 : 주방 서비스, 주문 서비스 등 사가 참여자는 원자적으로 메시지를 소비하고, 중복 메시지를 솎아 내고, 애그리거트를 생성/수정하고, 응답 메시지를 전송해야 함

### 6.3.1 코레오그래피 사가 구현: 이벤트 소싱
- 이벤트 소싱은 속성상 이벤트가 모든 것을 주도하므로 코레오그래피 사가를 아주 쉽게 구현할 수 있음
- 이벤트 소싱과 코래오그래피 사가는 찰떡 궁합

- 이벤트 소싱의 단점도 있음
  - 사가 코레오그래피에 이벤트를 사용하면 이벤트의 목적이 이원화됨
  - 이벤트 소싱은 상태 변화를 나타내기 위해 이벤트를 이용하는데, 이벤트 사가 코레오그래피에 갖다 쓰면 애그리거트는 상태 변화가 없어도 무조건 이벤트를 발생 시켜야 됨

### 6.3.2 오케스트레이션 사가 생성
- OrderService.createOrder() 같은 다른 서비스 메서드는 애그리거트를 생성/수정하고 하가 오케스트레이터를 생성하는 두 가지 일을 함

#### 사가 오케스트레이터 작성: RDBMS 이벤트 저장소 사용 서비스
- 이벤트 저장소를 업데이트하고 사가 오케스트레이터를 생성하는 작업을 한 트랜잭션으로 묶을 수 있음

#### 사가 오케스트레이터 작성: NoSQL 이벤트 저장소 사용 서비스
- NoSQL 이벤트 저장소를 사용하는 서비스는 이벤트 저장소를 업데이트하고 사가 오케스트레이터를 생성하는 액션을 원자적으로 수행할 수 없음

- 사가 오케스트레이터를 생성하는 이벤트 핸들러를 작성할 때 주의할 점은 중복 이벤트를 처리해야 한다는 사실
  - 가장 쉬운 방법은 이벤트의 유일한 속성에서 사가 ID를 추출하는 것  

### 6.3.3 이벤트 소싱 기반의 사가 참여자 구현
- 오케스트레이션 사가에 참여해야 하는 서비스를 이벤트 소싱으로 구현했다고 하면

- 이벤추에이트 트램 프레임워크와 동일한 트랜잭션으로 묶을 수 없는 이벤트 저장소를 이용하는 서비스는 전혀 다른 방법을 구사해야 함
- 다음 두 가지 이슈 해결
  - 커맨드 메시지를 멱등하게 처리
  - 응답 메시지를 원자적으로 전송


#### 커맨드 메시지를 멱등하게 처리
- 메시지를 처리할 때 생성되는 이벤트에 메시지 ID를 기록하면 사가 참여자는 다음에 애그리거트를 업데이트하기 전에 메시지 ID를 이벤트에서 꺼내 보고 자신이 이전에 이 메시지를 처리한적 있는지 확인

#### 응답 메시지를 원자적으로 전송
- 사가 오케스트레이터는 애그리거트가 발생시킨 이벤트를 구독할 수 있지만 두 가지 문제가 생김
  - 1) 사가 커맨드가 실제로 애그리거트 상태를 변경하지 않을지도 모름
  - 2) 이벤트 소싱을 이용하는 사가 참여자와 그렇지 않은 참여자를 사가 오케스트레이터가 다르게 취급해야 함

- 사가 참여자는 응답 메시지를 직접 보내는 것이 아니라 다음 2단계 프로세스를 거침
  - 1) 사가 커맨드 핸들러가 애그리거트를 생성/수정할 때, 애그리거트가 발생시킨 진짜 이벤트와 가짜 이벤트를 모두 이벤트 저장소에 저장
  - 2) 이벤트 핸들러는 이벤트에 포함된 데이터로 응답 메시지를 만들어 사가 오케스트레이터의 응답 채널에 출력 

#### 예제: 이벹느 소싱 기반의 사가 참여자
- 277P


### 6.3.4 사가 오케리스테이터 구현: 이벤트 소싱
- 사가 오케스트레이터를 구현하기 전에 고민해야 할 세 가지 설계 이슈
  - 1) 사가 오케스트레이터를 어떻게 저장할 것인가?
  - 2) 어떻게 오케스트레이터 상태를 원자적으로 변경하고 커맨드 메시지를 전송할 것인가?
  - 3) 어떻게 사가 오케스트레이터가 정확히 한 번만 메시지를 응답하게 만들 것인가?

#### 이벤트 소싱으로 사가 오케스트레이터 저장
- 사가 오케스트레이터는 단순함. 처음 생성된 다음부터는 사가 참여자의 응답에 반응하며 계속 업데이트 됨.

#### 커맨드 메시지를 확실하게 전송
- 이벤추에이트 트램 기반 사가는 오케스트레이터를 업데이트하고 커맨드 메시지를 메시지 테이블에 삽입하는 작업을 하나의 트랜잭션으로 묶어서 수행
- 이벤추에이트 SaaS 같은 NoSQL 이벤트 저장소를 사용하는 애플리케이션 역시 제한적이지만 비슷한 방법으로 접근 가능
  - 전송할 커맨드를 나타낸 SagaCommandEvent를 저장하는 것 

#### 응답을 꼭 한 번만 처리
- 오케스트레이터가 응답 메시지 ID를 이벤트에 보관하면 어느 메시지가 중복인지 쉽게 분간할 수 있음

## 6.4 마치며
- 이벤트 소싱은 애그리거트를 일련의 이벤트로 저장하며, 여기서 각 이벤트는 애그리거트의 생성 또는 상태 변화를 나타냄
- 스냅샷은 재연해야 할 이벤트 개수를 줄여 성능을 향상 시킴
- 이벤트는 DB와 메시지 브로커를 혼합한 형태인 이벤트 저장소에 저장됨
- 애플리케이션에서 이벤트 재연 시, 여러 버전의 이벤트를 처리해야 할 수도 있기 때문에, 이벤트 저장소에서 이벤트를 가져올 때 최근 버전으로 이벤트를 업캐스팅
- 이벤트 소싱 애플리케이션은 데이터를 삭제하기 까다로워서 암호화/가명화 등의 기법 사용
- 이벤트 소싱을 이용하면, 이벤트 소싱 기반의 애그리거트가 발행한 이벤트를 리스닝하는 이벤트 핸들러가 서비스에 달려 있기 때문에 코레오그래피 사가를 간단히 구현할 수 있음
- 이벤트 소싱은 사가 오케스트레이터를 구현하기 좋은 수단임
