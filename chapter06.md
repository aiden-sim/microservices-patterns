# 비즈니스 로직 개발:이벤트 소싱

## 6.1 이벤트 소싱 응용 비즈니스 로직 개발
- 이벤트 소싱은 비즈니스 로직을 구성하고 애그리거트를 저장하는 또 다른 방법
- 이벤트는 각 애그리거트의 상태 변화를 나타냄
  - 이벤트를 재연(replay)하여 애그리거트의 현재 상태를 재생성

- 이벤트 소싱 좋은 점
  - 애그리거트 이력이 보존되므로 감사/통제 용도로 사용
  - 도메인 이벤트를 확실하게 발생할 수 있어서 마이크로서비스 아키텍처에 특히 유용

- 이벤트 소싱 단점
  - 어느 정도 학습 비용 필요
  - 이벤트 저장소를 쿼리하기 쉽지 않아 CQRS 패턴 적용해야됨  

### 6.1.1 기존 영속화의 문제점
- 일반적으로 JPA 같은 ORM 프레임워크나 마이바티스등의 저수준 프레임워크를 사용하여 테이블의 로우 단위로 저장
- 다음과 같은 한계가 있음
  - 객체-관계 임피던스 부정합
  - 애그리거트 이력이 없음
  - 감사 로깅우르 구현하기가 번거로움
  - 이벤트 발행 로직이 비즈니스 로직에 추가됨

#### 객체-관계 임피던스 부정합
- 테이블 형태의 관계형 스키마와 관계가 복잡한 리치 도메인 모델의 그래프 구조는 근본적인 개념부터 다름

#### 애그리거트 이력이 없다
- 현재 애그리거트의 상태만 저장
- 애그리거트가 업데이트되면 이전 상태는 사라지고 없음

#### 감사 로깅은 구현하기 힘들고 오류도 자주 발생한다
- 감사 로깅 구현 시, 시간이 걸리는 것도 문제지만, 감사 로깅 코드 및 비즈니스 로직이 계속 분화하기 때문에 버그가 날 가능성도 높음

#### 이벤트 발행 로직이 비즈니스 로직에 추가된다
- 영속화는 도메인 이벤트 발행을 지원하지 않는다.
- 개발자는 이벤트 생성 로직을 추가해야 하는데, 비즈니스 로직과 동기화되지 않을 위험이 있음

### 6.1.2 이벤트 소싱 개요
- 이벤트 소싱은 이벤트를 위주로 비즈니스 로직을 구현하고, 애그리거트를 DB에 일련의 이벤트로 저장하는 기법
- 각 이벤트는 애그리거트의 상태 변화를 나타냄

#### 이벤트를 이용하여 애그리거트를 저장
- 이벤트 소싱은 도메인 이벤트 개념에 기반한 전혀 새로운 방식, 즉 애그리거트를 DB에 있는 이벤트 저장소에 일련의 이벤트로 저장

- 이벤트 재연 3단계
  - 1) 에그리거트의 이벤트를 로드
  - 2) 기본 생성자를 호출하여 애그리거트 인스턴스를 생성
  - 3) 이벤트를 하나씩 순회하며 apply()를 호출

- 함수형 프로그래밍 폴듀 or 리듀스 개념

#### 이벤트는 곧 상태 변화
- 이벤트에 무엇을 전달할지는 컨슈머의 필요에 따라 좌우되지만, 이벤트 소싱에서는 주로 애그리거트에 의해 이벤트 및 그 구조가 결정됨
- 이벤트 소싱에서는 이벤트가 필수이며, 모든 상태 변화를 도메인 이벤트로 나타냄

#### 애그리거트 메서드의 관심사는 오직 이벤트
- 기존에는 커맨드 메서드가 매개변수를 검증한 후 하나 이상의 애그리거트 필드를 업데이트했지만, 이벤트 소싱을 사용하면 커맨드 메서드가 반드시 이벤트를 발생시킴

- 이벤트를 발생시켜 적용하려면 이벤트 소싱은 커맨드 메서드 하나를 둘 이상의 메서드로 리팩터링 해야 함
  - 첫 번째 메서드는 요청을 나타낸 커맨드 객체를 매개변수로 받아 상태를 어떻게 변경해야 할지 결정
    - 매개변수 확인 후 애그리거트 상태는 바꾸지 않고 상태 변경을 나타낸 이벤트 목록을 반환
  - 두 번째 메서드는 정해진 이벤트 타입을 매개변수로 받아 애그리거트를 업데이트

#### 이벤트 소싱 기반의 Order 애그리거트
- 249P

### 6.1.3 동시 업데이트: 낙관적 잠금
- 기존 영속화 메커니즘은 한 트랜잭션이 다른 트랜잭션의 변경을 덮어 쓰지 못하게 낙관적 잠금(버전)으로 처리

- 이벤트 저장소 역시 낙관적 잠금 기법으로 동시 업데이트를 처리할 수 있음
  - 이벤트에 딸려온 버전 정보를 각 애그리거트 인스턴스마다 두고, 애플리케이션이 이벤트를 삽입할 때 이벤트 저장소가 버전 변경 여부를 체크 

### 6.1.4 이벤트 소싱과 이벤트 발행
- 이벤트 소싱 기반의 애플리케이션은, 이벤트를 OUTBOX 테이블에 잠깐 저장했다 지우는 것이 아니라, EVENTS 테이블에 영구 저장하는 중요한 차이점이 있음

#### 이벤트 발행: 폴링
- 이벤트를 EVENTS 테이블에 저장한다고 하면, 발행기에서는 마지막 EVENT_ID를 기록하면 됨

- 하지만 트랜잭션이 이벤트를 발생시키는 순서와 다르게 커밋할 수도 있음
  - 해결 방법은 EVENTS 테이블에 이벤트 발행 여부를 추적할 수 있는 컬럼 추가

#### 이벤트 발행: 트랜잭션 로그 테일링
- 트랜잭션 로그 테일링은 좀 더 정교한 방법
- 이벤트 발행을 확실히 보장하면서도 성능/확장성이 우수함

### 6.1.5 스냅샷으로 성능 개선
- 주기적으로 애그리거트 상태의 스냅샷을 저장하여 성능 개선
  - 최근에 뜬 스냅샷 + 그 이후 발생한 이벤트만 가져오는 방식으로 애그리거트 상태 복원

- 스냅샷을 사용할 경우, 애그리거트 인스턴스는 기본 생성자가 아닌 스냅샷을 이용하여 재생성함

### 6.1.6 멱등한 메시지 처리
- 메시지 브로커가 동일한 메시지를 여러 번 전송할 가능성이 있으므로 메시지 컨슈머는 멱등하게 개발해야 함
- 애그리거트를 생성/수정하는 로컬 ACID 트랜잭션의 일부로 처리한 메시지 ID를 PROCESSED_MESSAGE 테이블에 기록.
  - 이 테이블에 메시지 ID가 있으면 중복 메시지로 판단 

- 구현 방법은 이벤트 저장소가 관계형 DB 인지, NoSQL DB 인지에 따라 다름

#### RDBMS 이벤트 저장소 사용
- 메시지 ID는 PROCESSED_MESSAGE 테이블에, 이벤트는 EVENTS 테이블에 삽입하는 트랜잭션의 일부로 삽입

#### NoSQL 이벤트 저장소 사용
- 트랜잭션 모델이 제한적이라서 메시지를 멱등하게 처리하려면 다른 수단 강구
- 메시지 컨슈머가 메시지 처리 도중 생성된 메시지 ID를 저장
  - 해당 메시지 ID가 애그리거트의 이벤트 있는지 확인하면 중복 메시지 여부 확인 가능 

- 애그리거트가 이벤트를 발생시키지 않을 경우, 오직 메시지 ID를 기록할 목적으로 가짜 이벤트를 저장함
  - 이런 가짜 이벤트는 이벤트 컨슈머가 무시해야 함 

### 6.1.7 도메인 이벤트 발전시키기
- 이벤트 영구 저장은 양날의 검과 같다.
  - 이벤트 구조는 시간이 흐름에 따라 계속 달라지기 때문에 문제가 생길 수 있음

- 애플리케이션은 잠재적으로 여러 버전의 이벤트를 처리해야 함

#### 이벤트 스키마 
- 이벤트 소싱에 기반한 애플리케이션의 스키마는 개념상 다음 세 가지로 구성
  - 하나 이상의 애그리거트로 구성
  - 각 애그리거트가 발생시키는 이벤트를 정의
  - 이벤트 구조를 정의 

#### 업캐스팅을 통한 스키마 변화 관리
- SQL DB는 DB 스키마 변경은 보통 마이그레이션을 이용하여 처리
  - 플라이웨이 등의 툴 사용

- 이벤트 소싱은 이벤트 소싱 프레임워크가 이벤트 저장소에 이벤트를 로드할 때 변경해 줌

### 6.1.8 이벤트 소싱의 장점
- 도메인 이벤트를 확실하게 발행함
- 애그리거트 이력이 보존됨
- O/R 임피던스 불일치 문제를 대부분 방지할 수 있음
- 개발자에게 타임 머신을 제공함

#### 도메인 이벤트를 확실하게 발행
- 

#### 애그리거트 이력 보존

#### O/R 임피던스 불일치 문제를 거의 방지

#### 개발자에게 타임 머신 제공


### 6.1.9 이벤트 소싱의 단점


