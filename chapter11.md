# 프로덕션 레디 서비스 개발
- 서비스를 운영에 배포하려면 품질 속성(보안), 구성성, 관측성이 보장되어야 함
  - 품질 속성 : 보안으로, MSA는 기존 모놀리식 아키텍처와 차이 없음
  - 구성성 : 구성 프로퍼티를 외부화 (vault)
  - 관측성 : 각 분산되어 있는 로그, 모니터링에 대한 강화

## 11.1 보안 서비스 개발
- 네 가지 보안 요소
  - 인증 : 애플리케이션에 접근하는 주체의 신원 확인. id/password 등 자격증명
  - 인가 : 주체가 작업을  수 있는 권한이 있는지 확인. role, ACL
  - 감사 : 보안 이슈 탐지.
  - 보안 IPC : 서비스 간, TLS 경유하는게 이상적

### 11.1.1 기존 모놀리식 애플리케이션의 보안
- 사용자 id/password 통해 세션 토큰을 반환하고, 이후에 세션 토큰을 이용해서 사용

- 보안 아키텍처의 핵심은 세션
  - 보통 JSESSIONID라는 HTTP 쿠키

- 보안 컨텍스트 역시 보안 아키텍처의 주요 요소
  - 주체와 역할 관련 정보

### 11.1.2 마이크로서비스 아키텍처에서의 보안 구현
- 마이크로서비스 아키텍처에서 보안을 구현하려면 사용자의 인증/인가 처리를 누가 담당할지부터 결정해야 함

- 모놀리식에서 사용한 방법이 MSA 에서는 사용 못함
  - 인-메모리 보안 컨텍스트 : 서비스끼리 메모리 공유할 수 없으므로 인-메모리 보안 컨텍스트로 사용자 신원 전달 불가 
  - 중앙화 세션 : 느슨한 결합에 위배되긴 하지만 여러 서비스가 DB 기반의 세션에 접근하는 것은 가능. 하지만 MSA는 다른 방식 고려

#### API 게이트웨이 인증 처리
- 요청을 서비스에 보내기 전에 API 게이트웨이가 요청을 인증하는 것이 좋음
  - 나중에 문제가 생겨도 한곳만 바로잡으면 됨
  - 게이트웨이가 전담하기 때문에 복잡한 코드도 서비스에서 감출 수 있음

- 게이트웨이로부터 호출 받는 서비스는 요청 주체랑 인증 여부 등 확인해야 함 (게이트웨이에서 토큰을 함께 넣어서 보내 줌)

#### 인가 처리
- 권한 없는 사용자가 특정 경로에 접근할 경우, API 게이트웨이가 요청을 서비스에 포워딩하기 전에 간단히 거부

- API 게이트웨이에 인가 로직을 넣으면, 서비스와 단단히 결함하게 됨
- 게이트웨이는 역할 기반의 URL 경로 접근만 구현할 수 있으며, 개별 도메인 객체의 접근 권한을 제어하는 ACL 까지 구현하기 무리 (도메인 세부로직까지 알고 있어야 함)
  - 인가 로직은 서비스에 구현하는 것이 좋음

#### JWT로 사용자 신원/역할 전달
- 토근의 종류
  - 1) 난독화 토큰 (UUID)
    - 성능 및 가용성이 떨어지고 지연 시간이 김
  - 2) 투명 토큰 (JWT)
    - 사용자 정보, 만료일자 등 각종 메타데이터가 포함된 JSON 객체를 페이로드에 담아 생성자(게이트웨이), 수신자(서비스)만 알 수 있는 시크릿으로 서명
    - 탈취는 JWT의 만료로 보완

#### OAuth 2.0 응용
- 직접 구현 보다 OAuth 2.0 표준이 제대로 구현된 프레임워크 사용

- 핵심 개념 
  - 인증 서버 : 사용자 인증 및 액세스/리프레시 토큰 획득 API 제공
  - 액세스 토큰 : 리소스 서버 접근을 허가하는 토큰. (스프링 OAuth는 JWT를 사용)
  - 리프레시 토큰 : 클라이언트가 새 액세스 토큰을 얻기 위해 필요한 토큰 (취소 가능)
  - 리소스 서버 : 액세스 토큰으로 접근을 허가하는 서비스
  - 클라이언트 : 리소스 서버에 접근하려는 클라이언트

- OAuth 2.0 기반의 API 게이트웨이는 액세스 토큰을 세션 토큰처럼 이용해서 세션 지향 클라이언트를 인증할 수 있음
- 액세스 토큰이 만료된 경우, API 게이트웨이는 인증 서버에 OAuth 2.0 리프레시 승인을 요청해서 액세스 토큰을 새로 발급


## 11.2 구성 가능한 서비스 설계
- 프로퍼티를 소스 코드에 하드코딩 하거나, 스프링 프레임워크의 프로파일을 사용하는 구조는 보안에 취약하고 배포에 한계가 있음

- 외부화 구성 : 런타임에 DB 자격증명, 네트워크 위치 등 구성 프로퍼티 값을 서비스에 제공

- 외부화 구성 메커니즘
  - 푸시 모델 : OS 환경 변수, 구성 파일등을 통해 배포 인프라에서 서비스 프로퍼티 값을 전달
  - 풀 모델 : 서비스 인스턴스가 구성 서버에 접속해서 프로퍼티 값을 읽어 옴

### 11.2.1 푸시 기반의 외부화 구성
- 배포 환경은 서비스 인스턴스가 생성될 때 프로퍼티 값을 제공

- 스프링 부트가 프로퍼티 값을 읽어 올 수 있는 소스 (우선 순위)
  - 1) CLI 인수
  - 2) OS 환경 변수(SPRING_APPLICATION_JSON)
  - 3) JVM 시스템 프로퍼티
  - 4) OS 환경 변수
  - 5) 현재 디렉터리의 구성 파일 ex) '@Value'

- 실행 중인 서비스인 경우 재시동하지 않고서 바꿀 수 없는 경우가 있음
  
### 11.2.2 풀 기반의 외부화 구성
- 서비스 시동 시 자신이 필요한 값을 구성 전용 서버에 접속하여 읽는 방식

- 구성 서버 구현 방법
  - 버전 관리 시스템
  - SQL/NoSQL DB
  - 전용 구성 서버 (스프링 클라우드 컨피그 서버), 해시코프 볼트, AWS 파라미터 스토어 

- 구성 서버의 장점
  - 중앙화 구성 : 모든 구성 프로퍼티를 한 곳에서 관리해서 간편 (중복 프로퍼티 제거)
  - 민감한 데이터 투명한 복호화 : DB 자격증명 등 민감한 데이터는 암호화 필요. 구성 서버는 복호화해서 서비스에 전달 (vault)
  - 동적 재구성 : 수정된 프로퍼티 값을 폴링 등으로 감지해서 자동 재구성

## 11.3 관측 가능한 서비스 설계
- 관측 가능한 서비스를 설계하는 패턴
  - 헬스 체크 API : 서비스 헬스를 반환하는 끝점을 표출
  - 로그 수집 : 서비스 활동을 로깅하면서 검색/경고 기능이 구현된 중앙 로그 서버에 로그를 출력 (elk)
  - 분산 추적 : 각 외부 요청에 ID를 하나씩 붙여 서비스 사이를 드나드는 과정을 추적 (zipkin)
  - 예외 추적 : 예외 중복 제거, 개발자 알림, 예외별 해결 상황 추적  
  - 애플리케이션 지표 : 서비스는 카운터, 게이지 등 지표를 유지하고, 수집한 데이터를 지표 서버에 표출 (matrix)
  - 감사 로깅 : 사용자 액션을 로깅 (agit)

### 11.3.1 헬스 체크 API 패턴
- 실행 중이지만 요청을 받을 수 없는 인스턴스 체크

- 배포 인프라는 서비스 인스턴스 상태를 계속 살피고 문제가 있으면 즉시 조치할 수 있도록 주기적으로 헬스 체크 API 호출

#### 헬스 체크 끝점 구현
- 헬스 체크 끝점을 구현한 코드는 서비스 인스턴스의 상태를 판단해야 됨 (인프라 서비스 마다 방법이 다름)

#### 헬스 체크 끝점 호출
- 서비스를 배포할 때 배포 인프라가 헬스 체크 끝점을 호출하도록 구성

### 11.3.2 로그 수집 패턴
- 로그는 소중한 트러블 슈팅 도구

- MSA 로그 수집은 모든 서비스 인스턴스가 남긴 로그를 로그 수집 파이프라인을 통해 중앙 로깅 서버로 보냄

#### 서비스 로그 생성
- 적합한 로깅 라이브러리 선택 후(로그백,Log4J, SLF4J 등), 항목을 어디에 출력할지 정해야 함

#### 로그 수집 인프라
- ELK 스택 로깅 인프라
  - 일래스틱서치 : 로깅 서버로 쓰이는 텍스트 검색 지향 NoSQL DB
  - 로그스태시 : 서비스 로그를 수집하여 일래스틱서치에 출력하는 로그 파이프라인
  - 키바나 : 일래스틱서치 전용 시각화 툴

### 11.3.3 분산 추적 패턴
- 애플리케이션 상태를 확인하기 위해 분산 추적 활용

- 분산 추적은 각 서비스에 쓰이는 인스트루멘테이션 라이브러리와 분산 추적 서버, 두 부분으로 구성됨
  - 에이전트 (지표 수집 후 서버로 전송)
  - 서버 (통계, 시각화) 

#### 인스트루멘테이션 라이브러리
- AspectJ, 같은 AOP 방식을 이용 (기존 서비스 코드에 영향 없도록)

#### 분산 추적 서버
- 서버는 전달받은 스팬을 서로 짜집기해서 트레이스 형태로 만든 후 DB에 저장 (오픈 집킨 등)

### 11.3.4 애플리케이션 지표 패턴
- 모니터링 시스템은 기술 스택의 모든 부분에서 지표를 수집하여 중요한 애플리케이션 헬스 정보를 제공

- 지표 샘플의 세가지 속성 (name, value, timestamp)

- 모니터링 관련 개발자의 두가지 의무
  - 1) 서비스가 자신의 동작에 관한 지표를 수집하도록 구현 (에이전트 설치, 프로파일링)
  - 2) 이런 지표를 JVM 및 애플리케이션 프레임워크 수준에서 수집한 지표와 함께 지표 서버에 표출

#### 서비스 수준의 지표 수집
- 스프링 부트 서비스는 마이크로미터 메트릭스라는 라이브러리 추가 시, 기본 지표 수집 가능

#### 지표 서비스에 지표 전달
- 서비스는 수집한 지표를 푸시, 풀 방식으로 매트릭스 서비스에 전달
  - 푸시는 서비스가 API를 호출하여 매트릭스 서비스에 지표를 넣는 방법 ex) AWS 클라우드 워치
  - 풀은 매트릭스 서비스가 서비스 API 호출하여 지표를 당겨 오는 방식 ex) 프로메테우스 (그라파나를 통해 시각화 가능) 


### 11.3.5 예외 추적 패턴
- 예외는 문제의 근본 원인을 식별하는데 중요한 단서

- 로그 파일 검색이나 로그 파일 예외가 발생하면 알람 오도록 하는 로깅 서버 구성의 한계
  - 로그 파일 대부분 한 줄짜리 로그 항목이 많지만, 예외는 여러줄로 나옴
  - 로그 파일에 있는 예외의 해결 과정을 추적할 메커니즘이 없음
  - 중복된 예외를 자동으로 하나의 예외로 식별하여 처리할 방법이 없음 

- 예외 추적 서비스에 내장된 클라이언트 라이브러리 활용 ex) 허니배저, Sentry.io

### 11.3.6 감사 로깅 패턴
- 감사 로깅은 사용자의 액션을 기록

- 감사 로깅 구현 방법
  - 감사 로깅 코드를 비즈니스 로직에 추가
  - 애스팩트 지향 프로그래밍(AOP)을 활용
  - 이벤트 소싱을 이용 


#### 감사 로깅 코드를 비즈니스 로직에 추가
- 문제는 감사 로깅 코드와 비즈니스 로직이 한데 섞여 관리하기 쉽지 않음

#### 애스팩트 지향 프로그래밍 활용
- 메서드 호출을 자동 인터셉트하는 어드바이스(스프링 AOP)를 이용
  - 메서드명과 인수만 접근할 수 있어서 비즈니스 지향적인 감사 로그 항목을 만들기 어려움

#### 이벤트 소싱 이용
- 이벤트 소싱은 생성/수정 작업의 감사 로그를 자동으로 제공하는 기능이 있음
  - 쿼리는 기록하지 않기 때문에 쿼리를 별도 로그 항목으로 남겨야 할 경우 다른 방법 강구

## 11.4 서비스 개발: 마이크로서비스 섀시 패턴
- 마이크로서비스 섀시는 횡단 관심사 처리에 특화된 프레임워크
  - 서비스 코드와 분리할 수 있고, 개발 속도가 빨라짐, 중복제거 

### 11.4.1 마이크로서비스 섀시
- 다양한 관심사 처리
  - 외부화 구성
  - 헬스 체크
  - 애플리케이션 지표
  - 서비스 디스커버리
  - 회로 차단기
  - 분산 추적 

- 마이크로서비스 섀시를 적용하면 개발자가 작성해야 할 코드가 줄어듬 (덕분에 비즈니스 로직 개발에 전념)

### 11.4.2 이제는 서비스 메시로
- 마이크로서비스 섀시는 다양한 횡단 관심사 구현하기 좋은 수단이지만, 사용하는 프로그래밍 언어마다 하나씩 필요하다는 문제점
  - 이러한 문제를 해결하기 위해 공통 기능 일부를 서비스 외부에 위치한 서비스 메시에 구현

- 서비스 메시는 한 서비스와 다른 서비스, 그리고 외부 애플리케이션 간의 소통을 조정하는 인프라

- 이스티오, 링커드, 콘듀이트 등 제품 있음
