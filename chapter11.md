# 프로덕션 레디 서비스 개발
- 서비스를 운영에 배포하려면 품질 속성(보안), 구성성, 관측성이 보장되어야 함
  - 품질 속성 : 보안으로, MSA는 기존 모놀리식 아키텍처와 차이 없음
  - 구성성 : 구성 프로퍼티를 외부화 (vault)
  - 관측성 : 각 분산되어 있는 로그, 모니터링에 대한 강화

## 11.1 보안 서비스 개발
- 네 가지 보안 요소
  - 인증 : 애플리케이션에 접근하는 주체의 신원 확인. id/password 등 자격증명
  - 인가 : 주체가 작업을  수 있는 권한이 있는지 확인. role, ACL
  - 감사 : 보안 이슈 탐지.
  - 보안 IPC : 서비스 간, TLS 경유하는게 이상적

### 11.1.1 기존 모놀리식 애플리케이션의 보안
- 사용자 id/password 통해 세션 토큰을 반환하고, 이후에 세션 토큰을 이용해서 사용

- 보안 아키텍처의 핵심은 세션
  - 보통 JSESSIONID라는 HTTP 쿠키

- 보안 컨텍스트 역시 보안 아키텍처의 주요 요소
  - 주체와 역할 관련 정보

### 11.1.2 마이크로서비스 아키텍처에서의 보안 구현
- 마이크로서비스 아키텍처에서 보안을 구현하려면 사용자의 인증/인가 처리를 누가 담당할지부터 결정해야 함

- 모놀리식에서 사용한 방법이 MSA 에서는 사용 못함
  - 인-메모리 보안 컨텍스트 : 서비스끼리 메모리 공유할 수 없으므로 인-메모리 보안 컨텍스트로 사용자 신원 전달 불가 
  - 중앙화 세션 : 느슨한 결합에 위배되긴 하지만 여러 서비스가 DB 기반의 세션에 접근하는 것은 가능. 하지만 MSA는 다른 방식 고려

#### API 게이트웨이 인증 처리
- 요청을 서비스에 보내기 전에 API 게이트웨이가 요청을 인증하는 것이 좋음
  - 나중에 문제가 생겨도 한곳만 바로잡으면 됨
  - 게이트웨이가 전담하기 때문에 복잡한 코드도 서비스에서 감출 수 있음

- 게이트웨이로부터 호출 받는 서비스는 요청 주체랑 인증 여부 등 확인해야 함 (게이트웨이에서 토큰을 함께 넣어서 보내 줌)

#### 인가 처리
- 권한 없는 사용자가 특정 경로에 접근할 경우, API 게이트웨이가 요청을 서비스에 포워딩하기 전에 간단히 거부

- API 게이트웨이에 인가 로직을 넣으면, 서비스와 단단히 결함하게 됨
- 게이트웨이는 역할 기반의 URL 경로 접근만 구현할 수 있으며, 개별 도메인 객체의 접근 권한을 제어하는 ACL 까지 구현하기 무리 (도메인 세부로직까지 알고 있어야 함)
  - 인가 로직은 서비스에 구현하는 것이 좋음

#### JWT로 사용자 신원/역할 전달
- 토근의 종류
  - 1) 난독화 토큰 (UUID)
    - 성능 및 가용성이 떨어지고 지연 시간이 김
  - 2) 투명 토큰 (JWT)
    - 사용자 정보, 만료일자 등 각종 메타데이터가 포함된 JSON 객체를 페이로드에 담아 생성자(게이트웨이), 수신자(서비스)만 알 수 있는 시크릿으로 서명
    - 탈취는 JWT의 만료로 보완

#### OAuth 2.0 응용
- 직접 구현 보다 OAuth 2.0 표준이 제대로 구현된 프레임워크 사용

- 핵심 개념 
  - 인증 서버 : 사용자 인증 및 액세스/리프레시 토큰 획득 API 제공
  - 액세스 토큰 : 리소스 서버 접근을 허가하는 토큰. (스프링 OAuth는 JWT를 사용)
  - 리프레시 토큰 : 클라이언트가 새 액세스 토큰을 얻기 위해 필요한 토큰 (취소 가능)
  - 리소스 서버 : 액세스 토큰으로 접근을 허가하는 서비스
  - 클라이언트 : 리소스 서버에 접근하려는 클라이언트

- OAuth 2.0 기반의 API 게이트웨이는 액세스 토큰을 세션 토큰처럼 이용해서 세션 지향 클라이언트를 인증할 수 있음
- 액세스 토큰이 만료된 경우, API 게이트웨이는 인증 서버에 OAuth 2.0 리프레시 승인을 요청해서 액세스 토큰을 새로 발급


## 11.2 구성 가능한 서비스 설계
- 프로퍼티를 소스 코드에 하드코딩 하거나, 스프링 프레임워크의 프로파일을 사용하는 구조는 보안에 취약하고 배포에 한계가 있음

- 외부화 구성 : 런타임에 DB 자격증명, 네트워크 위치 등 구성 프로퍼티 값을 서비스에 제공

- 외부화 구성 메커니즘
  - 푸시 모델 : OS 환경 변수, 구성 파일등을 통해 배포 인프라에서 서비스 프로퍼티 값을 전달
  - 풀 모델 : 서비스 인스턴스가 구성 서버에 접속해서 프로퍼티 값을 읽어 옴

### 11.2.1 푸시 기반의 외부화 구성
- 배포 환경은 서비스 인스턴스가 생성될 때 프로퍼티 값을 제공

- 스프링 부트가 프로퍼티 값을 읽어 올 수 있는 소스 (우선 순위)
  - 1) CLI 인수
  - 2) OS 환경 변수(SPRING_APPLICATION_JSON)
  - 3) JVM 시스템 프로퍼티
  - 4) OS 환경 변수
  - 5) 현재 디렉터리의 구성 파일 ex) '@Value'

- 실행 중인 서비스인 경우 재시동하지 않고서 바꿀 수 없는 경우가 있음
  
### 11.2.2 풀 기반의 외부화 구성
- 서비스 시동 시 자신이 필요한 값을 구성 전용 서버에 접속하여 읽는 방식

- 구성 서버 구현 방법
  - 버전 관리 시스템
  - SQL/NoSQL DB
  - 전용 구성 서버 (스프링 클라우드 컨피그 서버), 해시코프 볼트, AWS 파라미터 스토어 

- 구성 서버의 장점
  - 중앙화 구성 : 모든 구성 프로퍼티를 한 곳에서 관리해서 간편 (중복 프로퍼티 제거)
  - 민감한 데이터 투명한 복호화 : DB 자격증명 등 민감한 데이터는 암호화 필요. 구성 서버는 복호화해서 서비스에 전달 (vault)
  - 동적 재구성 : 수정된 프로퍼티 값을 폴링 등으로 감지해서 자동 재구성

## 11.3 관측 가능한 서비스 설계



## 11.4 서비스 개발: 마이크로서비스 섀시 패턴




