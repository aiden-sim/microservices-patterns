# 프로세스 간 통신
- 모놀리식 애플리케이션은 대부분 언어 수준의 메서드나 함수를 통해 호출하기 때문에 IPC는 크게 신경 쓸 필요가 없다.
- 마이크로서비스 아키텍처는 여러 개의 서비스로 구성하며 협동하기 위해 IPC 사용

## 3.1 마이크로서비스 아키텍처 IPC 개요
- IPC 종류
  - REST나 gRPC 등 동기 요청/응답 기반 통신 메커니즘
  - AMQP, STOMP 등 비동기 메시지 기반의 통신 메커니즘
- 메시지 포맷 : JSON, XML, 아브로, 포로토콜 버퍼

### 3.1.1 상호 작용 스타일
- 클라이언트/서비스 간 상호 작용 스타일 두 가지 분류
  - 1) 일대일/일대다
    - 일대일 : 각 클라이언트 요청은 정확히 한 서비스가 처리
    - 일대다 : 각 클라이언트 요청은 열어 서비스가 협동하여 처리 (MSA) 
  - 2) 동기/비동기 
    - 동기 : 클라이언트는 서비스가 제시간에 응답하리라 기대하고 대기 도중 블로킹 할 수 있음
    - 비동기 : 클라이언트가 블로킹하지 않음. 응답은 즉시 전송되지 않아도 됨 

- 일대일 상호 작용 종류
  - 요청/응답 : 클라이언트는 서비스에 요청을 하고 응답을 기다림.클라이언트는 응답이 도착하리라 기대하고 대기 중 블로킹. 서비스가 서로 강하게 결합되는 상호 작용 스타일
  - 비동기 요청/응답 : 클라이언트는 서비스에 요청을 하고 서비스는 비동기적으로 응답. 클라이언트는 대기 중 블로킹하지 않고, 서비스는 오랫동안 응답하지 않을 수 있음 
  - 단방향 알림 : 클라이언트는 서비스에 일방적으로 요청만 하고 버시는 응답을 보내지 않음

- 일대다 상호 작용 종류
  - 발행/구독 : 클라이언트는 알림 메시지를 발행하고, 여기에 관심 있는 0개 이상의 서비스가 메시지를 소비
  - 발행/비동기 응답 : 클라이언트는 요청 메시지를 발행하고 주어진 시간 동안 관련 서비스가 응답하길 기다림

### 3.1.2 마이크로서비스 API 정의
- API와 인터페이스는 소프트웨어 개발의 핵심
- 잘 설계된 인터페이스는 유용한 기능은 표출하되 그 구현체는 감추어져 있기 때문에 클라이언트에 영향을 미치지 않고 코드를 고칠 수 있음

- 모놀리식은 대부분 프로그래밍 언어에 맞게 인터페이스 정의
- 마이크로서비스 API와 인터페이스가 똑같이 중요
  - 서비스 API는 서비스와 그 클라이언트 간의 약속
  - 문제는 서비스와 클라이언트는 함께 컴파일 되지 않는다. 때문에 호환되지 않는 API에 맞물려 배포되어도 런타임 시, 실패될 것이다.

- IDL(Interface Definition Language, 인터페이스 정의 언어)

- API는 어떤 IPC를 사용하느냐에 따라 그 내용이 결정됨
  - 메시징 : 메시지 채널, 메시지 타입, 메시지 포맷
  - HTTP : URL, HTTP 동사, 요청/응답 포맷으로 구성

### 3.1.3 API 발전시키기
- 모놀리식은 API를 변경하고 모든 호출부를 수정하는 일이 그리 어렵지 않다. (메서드로 이해함)
- 마이크로서비스는 클라이언트를 다른 팀에서 개발하는 경우가 대부분이기 때문에 서비스 API를 변경하기 어려움

#### 시맨틱 버저닝
- 시맨틱 버저닝은 원래 소프트웨어 패키지의 버저닝 용도로 쓰였지만, 분산 시스템의 API 버저닝에도 사용가능
- 규칙
  - MAJOR : 하위 호환되지 않는 변경분을 API에 적용 
  - MINOR : 하위 호환되는 변경분을 API에 적용
  - PATCH : 하위 호환되는 오류 수정

- REST API라면 메이저 버전을 URL 경로의 첫번째 엘리먼트로 사용
- 메시징 기반이라면 발행한 메시지에 버전 번호 사용

#### 하위 호환되는 소규모 변경
- 하위 호환
  - 옵션 속성을 요청에 추가
  - 속성을 응답에 추가
  - 새 작업을 추가

- 경고성 원칙 : 당신이 하는 일은 보수적으로, 다른 사람들이 하는 일은 관대하게 (OCP 비슷하다고 느낌)

#### 중대한 대규모 변경
- 클라 강제 업데이트가 힘들기 떄문에 일정ㄱ 기간 동안 신/구 버전 API 모두 지원
  - ex)
    - REST API : /v1, /v2
    - HTTP 컨텐트 협상 : application/vnd.example.resource+json; version=1

### 3.1.4 메시지 포맷
- IPC의 핵심은 메시지 교환. 대부분의 메시지는 데이터를 담고 있기 때문에 데이터 포맷은 중요한 설계 결정 항목
  - 범 언어적 메시지 포맷을 선택 ex) 자바 직렬화 사용 X 
- 메시지 포멧은 크게 텍스트와 이진 포맷으로 분류

#### 텍스트 메시지 포맷
- JSON, XML 등 텍스트 기반 포맷은 사람이 읽기 쉬움
- 메시지 컨슈머는 자신이 관심 있는 값만 골라 쓰고 나머지는 무시하면 되서, 스키마가 자주 변경되도 하위 호환성은 쉽게 보장됨

- JSON 스키마
  - 유효성 검증등 요긴할듯 (해당 데이터 길이는 10, 최소값,최대값)

- 텍스트 메시지 포맷의 단점은 메시지가 김 (오버헤드)

#### 이전 메시지 포맷
- 프로토 버퍼와 아브로가 대표적
  - 메시지 구조 정의에 필요한 타입 IDL을 제공하며, 컴파일러는 메시지를 직렬화/역직렬화 하는 코드를 생성

ex) https://developers.google.com/authorized-buyers/rtb/downloads/realtime-bidding-proto

## 3.2 동기 RPI(Remote Procedure Invocation) 패턴 응용 통신
- RPI는 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 회신하는 IPC
- ![스크린샷 2022-04-17 오후 9 29 11](https://user-images.githubusercontent.com/7076334/163714296-01a5dbaf-a1ae-4105-a383-03db713bddf6.png)
  - 클라의 프록시 인터페이스 -> RPI 프록시 어댑터 클래스 구현 -> RPI 서버 어댑터 클래스 -> 서버의 프록시 인터페이스 -> 비즈니스 로직 -> 응답도 동일

- 종류
  - REST, gRPC 

### 3.2.1 동기 RPI 패턴:REST
- 


#### REST 성숙도 모델

#### REST API

#### 요청 한 번으로 많은 리소스를 가져오기 어렵다

#### 작업을 HTTP 동사에 매핑하기 어렵다

#### REST의 장단점

