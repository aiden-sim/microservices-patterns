# 프로세스 간 통신
- 모놀리식 애플리케이션은 대부분 언어 수준의 메서드나 함수를 통해 호출하기 때문에 IPC는 크게 신경 쓸 필요가 없다.
- 마이크로서비스 아키텍처는 여러 개의 서비스로 구성하며 협동하기 위해 IPC 사용

## 3.1 마이크로서비스 아키텍처 IPC 개요
- IPC 종류
  - REST나 gRPC 등 동기 요청/응답 기반 통신 메커니즘
  - AMQP, STOMP 등 비동기 메시지 기반의 통신 메커니즘
- 메시지 포맷 : JSON, XML, 아브로, 포로토콜 버퍼

### 3.1.1 상호 작용 스타일
- 클라이언트/서비스 간 상호 작용 스타일 두 가지 분류
  - 1) 일대일/일대다
    - 일대일 : 각 클라이언트 요청은 정확히 한 서비스가 처리
    - 일대다 : 각 클라이언트 요청은 열어 서비스가 협동하여 처리 (MSA) 
  - 2) 동기/비동기 
    - 동기 : 클라이언트는 서비스가 제시간에 응답하리라 기대하고 대기 도중 블로킹 할 수 있음
    - 비동기 : 클라이언트가 블로킹하지 않음. 응답은 즉시 전송되지 않아도 됨 

- 일대일 상호 작용 종류
  - 요청/응답 : 클라이언트는 서비스에 요청을 하고 응답을 기다림.클라이언트는 응답이 도착하리라 기대하고 대기 중 블로킹. 서비스가 서로 강하게 결합되는 상호 작용 스타일
  - 비동기 요청/응답 : 클라이언트는 서비스에 요청을 하고 서비스는 비동기적으로 응답. 클라이언트는 대기 중 블로킹하지 않고, 서비스는 오랫동안 응답하지 않을 수 있음 
  - 단방향 알림 : 클라이언트는 서비스에 일방적으로 요청만 하고 버시는 응답을 보내지 않음

- 일대다 상호 작용 종류
  - 발행/구독 : 클라이언트는 알림 메시지를 발행하고, 여기에 관심 있는 0개 이상의 서비스가 메시지를 소비
  - 발행/비동기 응답 : 클라이언트는 요청 메시지를 발행하고 주어진 시간 동안 관련 서비스가 응답하길 기다림

### 3.1.2 마이크로서비스 API 정의
- API와 인터페이스는 소프트웨어 개발의 핵심
- 잘 설계된 인터페이스는 유용한 기능은 표출하되 그 구현체는 감추어져 있기 때문에 클라이언트에 영향을 미치지 않고 코드를 고칠 수 있음

- 모놀리식은 대부분 프로그래밍 언어에 맞게 인터페이스 정의
- 마이크로서비스 API와 인터페이스가 똑같이 중요
  - 서비스 API는 서비스와 그 클라이언트 간의 약속
  - 문제는 서비스와 클라이언트는 함께 컴파일 되지 않는다. 때문에 호환되지 않는 API에 맞물려 배포되어도 런타임 시, 실패될 것이다.

- IDL(Interface Definition Language, 인터페이스 정의 언어)

- API는 어떤 IPC를 사용하느냐에 따라 그 내용이 결정됨
  - 메시징 : 메시지 채널, 메시지 타입, 메시지 포맷
  - HTTP : URL, HTTP 동사, 요청/응답 포맷으로 구성

### 3.1.3 API 발전시키기
- 모놀리식은 API를 변경하고 모든 호출부를 수정하는 일이 그리 어렵지 않다. (메서드로 이해함)
- 마이크로서비스는 클라이언트를 다른 팀에서 개발하는 경우가 대부분이기 때문에 서비스 API를 변경하기 어려움

#### 시맨틱 버저닝
- 시맨틱 버저닝은 원래 소프트웨어 패키지의 버저닝 용도로 쓰였지만, 분산 시스템의 API 버저닝에도 사용가능
- 규칙
  - MAJOR : 하위 호환되지 않는 변경분을 API에 적용 
  - MINOR : 하위 호환되는 변경분을 API에 적용
  - PATCH : 하위 호환되는 오류 수정

- REST API라면 메이저 버전을 URL 경로의 첫번째 엘리먼트로 사용
- 메시징 기반이라면 발행한 메시지에 버전 번호 사용

#### 하위 호환되는 소규모 변경
- 하위 호환
  - 옵션 속성을 요청에 추가
  - 속성을 응답에 추가
  - 새 작업을 추가

- 경고성 원칙 : 당신이 하는 일은 보수적으로, 다른 사람들이 하는 일은 관대하게 (OCP 비슷하다고 느낌)

#### 중대한 대규모 변경
- 클라 강제 업데이트가 힘들기 떄문에 일정ㄱ 기간 동안 신/구 버전 API 모두 지원
  - ex)
    - REST API : /v1, /v2
    - HTTP 컨텐트 협상 : application/vnd.example.resource+json; version=1

### 3.1.4 메시지 포맷
- IPC의 핵심은 메시지 교환. 대부분의 메시지는 데이터를 담고 있기 때문에 데이터 포맷은 중요한 설계 결정 항목
  - 범 언어적 메시지 포맷을 선택 ex) 자바 직렬화 사용 X 
- 메시지 포멧은 크게 텍스트와 이진 포맷으로 분류

#### 텍스트 메시지 포맷
- JSON, XML 등 텍스트 기반 포맷은 사람이 읽기 쉬움
- 메시지 컨슈머는 자신이 관심 있는 값만 골라 쓰고 나머지는 무시하면 되서, 스키마가 자주 변경되도 하위 호환성은 쉽게 보장됨

- JSON 스키마
  - 유효성 검증등 요긴할듯 (해당 데이터 길이는 10, 최소값,최대값)

- 텍스트 메시지 포맷의 단점은 메시지가 김 (오버헤드)

#### 이전 메시지 포맷
- 프로토 버퍼와 아브로가 대표적
  - 메시지 구조 정의에 필요한 타입 IDL을 제공하며, 컴파일러는 메시지를 직렬화/역직렬화 하는 코드를 생성

ex) https://developers.google.com/authorized-buyers/rtb/downloads/realtime-bidding-proto

## 3.2 동기 RPI(Remote Procedure Invocation) 패턴 응용 통신
- RPI는 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 회신하는 IPC
- ![스크린샷 2022-04-17 오후 9 29 11](https://user-images.githubusercontent.com/7076334/163714296-01a5dbaf-a1ae-4105-a383-03db713bddf6.png)
  - 클라의 프록시 인터페이스 -> RPI 프록시 어댑터 클래스 구현 -> RPI 서버 어댑터 클래스 -> 서버의 프록시 인터페이스 -> 비즈니스 로직 -> 응답도 동일

- 종류
  - REST, gRPC 

### 3.2.1 동기 RPI 패턴:REST
- REST는 HTTP로 소통하는 IPC
- 리소스는 REST의 핵심 개념 (비즈니스 객체 의미)
- REST는 HTTP 동사를 사용해 리소스를 가공 (GET, POST, PUT, DELETE)

#### REST 성숙도 모델
- REST의 성숙도
  - 레벨 0: 클라이언트는 HTTP POST 요청을 하여 서비스를 호출 (Method를 다 사용하지 않는다는걸로 이해)
  - 레벨 1: 서비스는 리소스 개념을 지원. 
  - 레벨 2: 서비스는 HTTP 동사(GET, POST, PUT 등)를 이용해 액션을 수행, 필요시 매개변수 저장. 덕분에 GET 요청을 캐싱
  - 레벨 3: HATEOAS(헤이티오스) 원칙에 기반하여 설계. HATEOAS를 사용하면 하드 코딩한 URL을 클라이언트 코드에 욱여 넣지 않아도 됨 (assetManager 에서 사용할 수 있을까?)

#### REST API
- REST는 원래 IDL이 없었지만 필요하다는 공감대가 확산되어 스웨거라는 오픈소스를 발전시켜 오픈 API명세가 REST IDL로서 보급
  - 인터페이스 정의를 기반으로 클라이언트 스텁(stub), 서버 스켈레톤을 생성하는 툴이 포함

#### 요청 한 번으로 많은 리소스를 가져오기 어렵다
- REST 리소스는 Consumer, Order 같은 비즈니스 객체 중심이기 때문에 클라이언트가 요청 한번으로 연관된 객체를 모두 가져올 수 있을지 고민
  - ex) GET /orders/order-id-1234?expand=consumer
- 시나리오가 복잡해지면 효율이 떨어지고 구현 시간이 많이 소요
  - GraphQL, 넷플릭스 팔코등 대체 API 기술 

#### 작업을 HTTP 동사에 매핑하기 어렵다
- 수정 시, PUT 동사를 쓰지만, 주문 취소/변경 등 다양할 수 있고멱등성이 보장되지 않는 업데이트도 있음
  - 리소스의 특정 부위를 업데이트하는 하위 리소스 정의
  - ex) 주문 취소 : POST /orders/{orderId}/cancel, 주문 변경 : POST /orders/{orderId}/revise 

- REST 대체의 gRPC 대체 기술이 인기 (gRPC로 사용 시, 동사 매핑 이점이 무엇인지 잘 모르겠음)
 
#### REST의 장단점
- 장점
  - 단순하고 익숙함
  - CLI 도구를 사용해 HTTP API 간편하게 테스트 가능 ex) Postman, curl
  - 요청/응답 스타일의 통신을 직접 지원
  - HTTP는 방화벽 친화적임 (방화벽 입장에서 쉽게 접근 가능한 특성을 지니고 있음)
  - 중간 브로커가 필요하지 않기 때문에 시스템 아키텍처가 단순해짐

- 단점
  - 요청/응답 스타일의 통신만 지원
  - 가용성 떨어짐 (클라-서버 직접 통신 하기 때문에 양쪽 다 실행중이어야함)
    - 중간에 메시지 브로커가 있으면 잠깐 다운되도 메시지 유실 X
  - 서비스 인스턴스의 위치를 클라에서 알고 있어야 함. (서비스 디스커버리 이용하면 큰 단점은 아님)
  - 요청 한 번으로 여러 리소스를 가져오기 어려움
  - 다중 업데이트 작업을 HTTP 동사에 매핑하기 어려울 때가 있음

### 3.2.2 동기 RPI 패턴: gRPC
- gRPC는 다양한 언어로 클라이언트/서버를 작성할 수 있는 프레임워크
  - generate 사용 (C#, Node.js, java) 
- gRPC는 이진 메시지 기반의 프로토콜이므로 서비스를 API 우선 방식으로 설계할 수 밖에 없음
- gRPC API는 하나 이상의 서비스와 요청/응답 메시지 데피니션(정의한 코드)로 구성됨
- gRPC는 프로토콜 버퍼 메시지 포맷을 사용 (이진 포맷)

- 장점
  - 다양한 업데이트 작업이 포함된 API를 설계하기 쉬움
  - 특히 큰 메시지를 교환할 때 콤팩트하고 효율적인 IPC 
    - ex)OpenRTB 규약
  - 양방향 스트리밍 덕분에 RPI, 메시징 두 가지 통신 방식 모두 가능
  - 다양한 언어로 작성된 클라이언트/서버 간 연동 가능
  - **json에 비해 성능 우세**

- 단점
  - 자바스크립트 클라가 하는일이 REST/JSON 기반 API보다 많음
  - 구형 방화벽은 HTTP/2를 지원하지 않음

### 3.2.3 부분 실패 처리: 회로 차단기 패턴
- 분산 시스템은 서비스가 다른 서비스를 동기 호출할 때마다 부분 실패 가능성이 항상 존재
  - 클라이언트는 응답 대기 도중 블로킹되기 때문에 전체 시스템의 중단을 초래할 위험도 있음

- 회로 차단기 패턴 : 연속 실패 횟수가 주어진 임계치를 초과하면 일정 시간 동안 호출을 즉시 거부하는 RPI 프록시

- ![스크린샷 2022-04-17 오후 10 24 22](https://user-images.githubusercontent.com/7076334/163716305-652f786d-35f8-49eb-a898-870d3c43f290.png)
  - 게이트웨이에 OrderServiceProxy를 그대로 구현하면 응답을 기다리기 위해 무한정 블로킹 됨. 리소스 고갈로 전체 API 사용 불능으로 이어짐
  - 솔루션
    - 무응답 원격 서비스를 처리하기 위해 OrderServiceProxy 같은 견고한 RPI 프록시를 설계
    - 원격 서비스가 실패하면 어떻게 조치해야 할지 결정

#### 견고한 RPI 프록시 설계
- 다른 서비스 동기 호출 시, 자기 스스로 방어하는 방법
  - 네트워크 타임아웃 : 항상 타임아웃을 걸어 무한정 블로킹 방지
  - 미처리 요청 개수 제한 : 클라이언트에 미처리 요청의 최대 개수 설정. 넘어가면 즉시 실패 (retry 횟수로 이해)
  - 회로 차단기 패턴 : 성공/실패 요청 개수를 지켜보다 에러율이 임계치를 초과하면 그 이후 시도 바로 실패

#### 불능 서비스 복구
- ![스크린샷 2022-04-17 오후 10 32 31](https://user-images.githubusercontent.com/7076334/163716600-c8f1f274-1bef-4c13-8849-51603f7b87e8.png)
  - 주문 데이터(가장 중요한) 외에 데이터는 상대적으로 덜 중요 하기 때문에 API 게이트웨이는 캐시된 버전의 데이터 또는 에러를 반환
  - 배달 서비스 불능인 경우, 캐시 데이터를 반환하거나, 아얘 응답에서 제거

### 3.2.4 서비스 디스커버리
- 요즘 클라우드 기반의 마이크로서비스는 네트워크 위치가 동적이라서 이를 식별하기 위해 서비스 디스커버리를 사용
  - 자동 확장(스케일 아웃), 업그레이드(스케일 인), 실패 등의 사유

#### 서비스 디스커버리 개요
- 핵심은 애플리케이션 서비스 인스턴스의 네트워크 위치를 DB화 한 서비스 레지스트리
- 서비스 인스턴스가 시작/종료 시, 서비스 레지스트리 업데이트 되고, 클라이언트가 서비스 호출하면 디스커버리가 서비스 레지스트리에서 가용 인스턴스 목록 가져오고 그중 한 서비스로 요청을 라우팅 함

- 서비스 디스커버리 구현 방식
  - 클라이언트/서비스가 직접 서비스 레지스트리와 상호 작용
  - 배포 인프라로 서비스 디스커버리를 처리 

#### 애플리케이션 수준의 서비스 디스커버리 패턴 적용
- 애플리케이션 클라이언트/서비스가  서비스 레지스트리와 직접 통신 하는 방법
- ![스크린샷 2022-04-18 오전 1 21 36](https://user-images.githubusercontent.com/7076334/163723348-fb585ec3-f882-49ad-a4c0-6c42be85f50f.png)
  - 두가지 패턴 조합
    - 자가 등록 패턴 : 서비스 인스턴스는 서비스 레지스트리에 자기 자신을 등록
    - 디스커버리 패턴 : 클라이언트는 서비스 레지스트레 있는 가용 서비스 인스턴스 목록을 조회하고 부하 분산 

- 장점
  - 다양한 플랫폼에 서비스가 배포된 경우에도 처리 가능
  - ex) 쿠버네티스 기반한 디스커버리는 쿠버네티스에서만 동작, 유레카를 이용한 (애플리케이션 수준)은 환경 상관 없음 

- 단점
  - 사용하는 언어(프레임워크)에 맞는 서비스 디스커버리 라이브러리가 필요함
  - 서비스 레지스트리를 직접 설정/관리하는 업무가 가중되는 부담도 있음

#### 플랫폼에 내장된 서비스 디스커버리 패턴 적용
- 도커나 쿠버네티스등 배포 플랫폼에는 대부분 서비스 레지스트리, 서비스 디스커버리 메커니즘 탑재
- 클라이언트가 DNS명/VIP를 요청하면 배포 플랫폼이 알아서 가용 서비스 인스턴스 중 하나로 요청을 라우팅함
- ![스크린샷 2022-04-18 오전 1 30 18](https://user-images.githubusercontent.com/7076334/163723647-7e9154f5-0df8-49eb-9159-000537ea2cdc.png)
  - 배포 플랫폼이 서비스 등록, 서비스 디스커버리, 요청 라우팅을 전부 관장
  - 두가디 패턴 접목
    - 서드파티 등록 패턴 : 서비스가 직접 레지스트리에 등록 하는 것이 아니라, 배포 플랫폼의 일부인 등록기라는 서드파티가 이 작업을 대행
    - 서버 쪽 디스커버리 패턴 : 클라이언트는 DNS로 요청 하면, 서비스 레지스트리를 쿼리하고 요청을 부하 분산하는 요청 라우터로 해석 됨


- 장점
  - 서비스 디스커버리를 모두 배포 플랫폼이 처리해 주기 때문에 아주 편리함
  - 서비스 개발 언어 상관 없이 모든 클라이언트/서비스에 바로 적용 가능

- 단점
  - 해당 플랫폼으로 배포한 서비스 디스커버리만 지원 (쿠버네티스 디스커버리는 쿠버네티스로 배포한 서비스에만 적용)


## 3.3 비동기 메시징 패턴 응용 통신
- 메시징은 서비스가 메시지를 서로 비동기적으로 주고 받는 통신 방식
- 보통 중개 역할을 하는 브로커를 사용하지만, 서비스가 직접 서로 통신하는 브로커리스 아키텍처도 있음

### 3.3.1 메시징 개요
- 송신자가 채널에 메시지를 쓰면 수신자는 채널에서 메시지를 읽음

#### 메시지
- 메시지는 헤더와 본문으로 구성 됨
  - 헤더는 데이터에 관한 메타데이터에 해당하는 키/값으로 구성.
  - 본문은 텍스트 또는 이진 포맷 데이터 

- 메시지 종류
  - 문서 : 데이터만 포함된 제네릭한 메시지. 메시지를 어떻게 해석할지는 수신자가 결정
  - 커멘드 : RPC 요청과 동등한 메시지, 호출할 작업과 전달할 매개변수가 지정되어 있음
  - 이벤트 :  송신자에게 어떤 사건이 발생했음을 알리는 메시지. 대부분 도메인 객체의 상태 변화를 나타내는 도메인 이벤트

#### 메시지 채널
- 메시지는 채널을 통해 교환
- ![스크린샷 2022-04-18 오전 1 46 24](https://user-images.githubusercontent.com/7076334/163724262-a17dd748-a538-4d3e-9756-0253376713f2.png)
  - 송신자(포트 & 어댑터) -> 메시지 채널 -> 수신자 (어댑터 & 포트)


- 채널의 종류
  - 점대점 채널(일대일) : 채널을 읽는 컨슈머 중 딱 하나만 지정하여 메시지를 전달 (ex 커멘드 메시지)
  - 발행-구독 채널(일대다) : 같은 채널을 바라보는 모든 컨슈머에 메시지를 전달함 (ex 이벤트 메시지)

### 3.3.2 메시징 상호 작용 스타일 구현
- 스타일에 따라 메시징으로 직접 구현 가능한 것도 있고, 메시징을 토대로 구현해야 하는 것도 있음

#### 요청/응답 및 비동기 요청/응답
- 클라이언트/서비스는 한 쌍의 메시지를 주고받는 비동기 요청/응답 스타일로 상호 작용
- ![스크린샷 2022-04-18 오전 1 56 56](https://user-images.githubusercontent.com/7076334/163724646-6637f98f-1dd0-42ea-a8e1-6e6421f64c50.png)
  - 클라이언트는 수행할 작업과 매개변수가 담긴 커맨드 메시지를 서비스의 점대점 메시징 채널로 보냄
    - 헤더에 MessageId와 응답 채널 명시 
  - 서비스는 요청을 처리한 후 결과를 담긴 응답 메시지를 클라이언트가 소유한 점대점 채널로 돌려 보냄
    - correlationId(코럴레이션) 포함된 응답 메시지
    - 클라는 correlationId 이용하여 응답 메시지와 요청을 맞추어 볼 수 있음

#### 단방향 알림
- 서비스가 소유한 점대점 채널로 클라이언트가 메시지(커맨드 메시지)를 보내면, 서비스는 이 채널을 구독해서 메시지를 처리하는 구조 (응답 없음)

#### 방행/구독
- 클라이언트는 여러 컨슈머가 읽는 발행/구독 채널에 메시지를 발행
- 서비스는 도메인 객체의 변경 사실을 알리는 도메인 이벤트를 발행
  - 서비스는 해당 도메인 클래스의 이름을 딴 발행/구독 채널을 소유

#### 발행/비동기 응답
- 앞에서 얘기한 **요청/응답 및 비동기 요청/응답** 이랑 비슷한 얘기인듯


### 3.3.3 메시징 기반 서비스의 API 명세 작성
- 서비스의 비동기 API 명세에는 메시지 채널명, 각 채널을 통해 교환되는 메시지 타입과 포맷을 명시(JSON, XML, 프로토콜 버퍼 등 표준 포맷 기술)
- 채널 및 매시지 타입은 딱히 표준이 없음

#### 비동기 작업 문서화
- 서비스 작업은 두 가지 상호 작용 스타일 중 하나로 호출할 수 있음
  - 요청/비동기 응답 스타일 API : 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷, 서비스가 반환하는 응답 메시지의 타입과 포맷으로 구성
  - 단방향 알림 스타일 API : 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷으로 구성

#### 발행 이벤트 문서화
- 서비스는 발행/구독 스타일로도 이벤트를 발행할 수 있음
  - 이벤트 채널, 서비스가 채널에 발행하는 이벤트 메시지의 타입과 포맷으로 구성됨 (발행 하는쪽 기준) 


### 3.3.4 메시지 브로커
- 메시지 브로커는 서비스가 서로 통신할 수 있게 해주는 인프라 서비스
- 서버가 직접 통신하는 브로커리스 기반의 메시징 아키텍처도 있음

#### 브로커리스 메시징
- 서비스끼리 메시지를 직접 교환 ex) ZeroMQ

- 장점
  - 송신자에서 수신자로 직접 전달하므로 네트워크 트래픽이 가볍고 지연 시간이 짦음
  - 메시지 브로커가 성능 병목적임아 SPOF가 될일이 없음
  - 메시지 브로커를 설정/관리할 필요가 없으므로 운영 복잡도가 낮음

- 단점
  - 서비스가 서로 위치를 알고 있어야 해서, 서비스 디스커버리 사용
  - 송신자/수신자 모두 실행 중이어야 하므로 가용성이 떨어짐
  - 전달 보장 같은 메커니즘을 구현하기 더 어려움
    - 브로커가 있는 경우 commit 여부 확인 가능

#### 브로커 기반 메시징 개요
- 송신자가 메시지 브로커에 메시지를 쓰면 메시지 브로커는 메시지를 수신자에게 전달

- 장점
  - 송신자가 컨슈머의 네트워크 위치를 몰라도 됨
  - 브로커에 메시지를 버퍼링 할 수 있음

- 종류
  - ActiveMQ
  - RabbitMQ
  - 아파치 카프카
  - AWS (키네시스, SQS)

- 브로커 검토 항목
  - 프로그래밍 언어 지원 여부
  - 메시징 표준 지원 여부
  - 메시지 순서 보장
  - 전달 보장
  - 영속화
  - 내구성
  - 확장성
  - 지연 시간
  - 경쟁사 컨슈머 지원 

- 브로커마다 일장일단이 있음. 하지만 메시징 순서 유지 및 확장성은 필수 요건

#### 메시지 브로커로 메시지 채널 구현
- 메시지 채널은 메시지 브로커마다 구현 방식이 조금씩 다름
- ![스크린샷 2022-04-18 오전 9 46 00](https://user-images.githubusercontent.com/7076334/163738566-8e97c821-6764-4073-9a23-f2e3b475a1a9.png)
  - 큐 : FIFO. 하나의 Consumer만 받을 수 있음
  - 토픽 : 발행/구독 (다수가 구독)
  - 참고) redis도 pub/sub 형태로 사용할 수 있음

#### 브로커 기반 메시징의 장단점
- 장점
  - 느슨한 결합 : 클라이언트는 서비스를 몰라도 되므로 디스커버리 메커니즘 필요 없음
  - 메시지 버퍼링 : HTTP 같은 동기 프로토콜은 클라/서비스 모두 가동 해야되지만, 메시징은 컨슈머가 처리할 때까지 큐에 쌓임
  - 유연한 통신 : 메시징은 지금까지 설명한 모든 상호 작용 스타일을 지원
  - 명시적 IPC : RPC는 원격 서비스를 로컬인양 호출

- 단점
  - 성능 병목 가능성 : 메시지 브로커가 성능 병목점이 될 위험이 있음 (대부분 브로커는 확장에 유연하게 설계)
  - 단일 장애점 가능성 : 메시지 브로커는 가용성이 높아야 함 (대부분 브로커는 고가용성 보장)
  - 운영 복잡도 부가 : 메시징 시스템 관리

### 3.3.5 수신자 경합과 메시지 순서 유지
- 메시지 순서를 유지한 채 메시지 수신자를 수평 확장(scale-out) 할 수 있을까?
- 카프카, AWS 키네시스 등 샤딩된 채널을 이용

- ![스크린샷 2022-04-18 오전 10 12 47](https://user-images.githubusercontent.com/7076334/163739734-c911fcfc-6742-4c0b-9e94-0ec07d3920d6.png)
  - 세 부분으로 구성
    - 1) 샤딩된 채널은 복수의 샤드로 구성되며, 각 샤드는 채널처럼 작동
    - 2) 송신자는 메시지 헤더에 샤드 키를 지정. 메시지 브로커는 메시지를 샤드 키별로 샤드/파티션에 배정. (우리 jedis 방식이랑 비슷)
    - 3) 메시징 브로커는 여러 수신자 인스턴스를 묶어 마치 동일한 논리 수신자처럼 취급 (컨슈머 그룹)
      - 동일한 orderId는 해시값이 같기 때문에 동일한 샤드에 배치되고 한 컨슈머 인스턴스에서만 메시지를 읽기 때문에 처리 순서 보장

### 3.6.6 중복 메시지 처리
- 클라이언트나 네트워크 또는 브로커 자신이 실패할 경우, 같은 메시지를 여러 번 전달할 수도 있음
- 중복 메시지를 처리하는 두가지 
  - 멱등한 메시지 핸들러를 작성
  - 메시지를 추적하고 중복을 솎아 냄 

#### 멱등한 메시지 핸들러 작성
- 멱등성 : 동일한 입력 값을 반복 호출해도 부수 효과가 없음
- 메시지 재전송 시, 브로커가 순서를 유지한다는 전제하에 멱등한 메시지 핸들러는 여러 번 실행해도 별 문제 없음
  - 멱등한 애플리케이션 로직은 실제로 별로 없음 

#### 메시지 추적과 중복 메시지 솎아 내기
- 컨슈머가 메시지 ID를 이용하여 중복 메시지를 솎아 내면 간단히 해결됨
- ![스크린샷 2022-04-18 오전 10 28 28](https://user-images.githubusercontent.com/7076334/163740629-3a47dfe7-46b6-452e-aa56-b8e5c1a72d51.png)
  - 중복 메시지라면 DB 트랜잭션 수준에서 실패됨
  - ex) 빌링쪽 충전/상환 시 이렇게 되어 있음


### 3.3.7 트랜잭셔널 메시징
- 서비스는 보통 DB를 업데이트하는 트랜잭션의 일부로 메시지를 발행 (이벤트 메시지)
  - 원자적으로 미 수행 시, 시스템이 실패할 경우 불안정한 상태가 됨 (싱크 안맞음)

- 예전에는 분산 트랜잭션을 적용했지만 요즘은 어울리지 않음 (사가패턴)

#### DB 테이블을 메시지 큐로 활용
- RDBMS 기반이라면 DB 테이블을 임시 메시지 큐로 사용하는 트랜잭셔널 아웃 박스 패턴이 가장 알기 쉬운 방법
  - 메시지 보내는 서비스에 OUTBOX DB 테이블을 만들고, 비즈니스 객체를 생성,수정,삭제 하는 DB 트랜잭션 일부로 OUTBOX 테이블에 메시지 삽입 (ACID 트랜잭션이라 원자성 보장)
  - OUTBOX는 임시 메시지 큐 역할
  - 메시지 릴레이(중계기)는 OUTBOX 테이블을 읽어 메시지 브로커에 메시지를 발행

- 메시지를 DB에서 메시지 브로커로 옮기는 두가지 방법
  - 폴링 발행 패턴
  - 트랜잭션 로그 테일링 패턴 

#### 이벤트 발행: 폴링 발행기 패턴
- 메시지 릴레이 테이블을 폴링해서 조회 (오름 차순 쿼리). 브로커에 발행된 메시지는 OUTBOX 테이블에서 메시지 삭제
- DB 폴링은 규모가 작은 경우 사용하는 단순한 방법
  - 자주 폴링하면 비용 유발, 쿼리 속도에 따른 사용 가능 여부

#### 이벤트 발행: 트랜잭션 로그 테일링 패턴
- 메시지 릴레이(중계기)로 DB 트랜잭션 로그(커밋로그)를 테일링 하는 방법
- ![스크린샷 2022-04-18 오전 11 29 43](https://user-images.githubusercontent.com/7076334/163745078-6edc3596-419a-41f0-847a-2613d714c334.png)
  - 트랜잭션 로그 마이너로 로그를 읽어 변경분을 하나씩 메시지 브로커에 발행

- 응용 사례
  - 디비지움 : DB 변경분을 아파치 카프카 메시지 브로커에 발행하는 오픈소스
  - 링크드인 데이터버스 : 오라클 트랜잭션 로그를 마이닝하여 변경분을 이벤트로 발행하는 오픈소스
  - DynamoDB 스트림즈 : AWS DynamoDB 의 변경분(생성, 수정, 삭제)를 시간 순으로 읽어 이벤트로 발행
  - 이벤추에이트 트램 : 필자가 개발한 오픈 소스 트랜잭션 메시징 라이브러리 (폴링 응용)

### 3.3.8 메시징 라이브러리/프레임워크
- 메시지 브로커의 클라이언트 라이브러리를 직접 사용 시, 다음과 같은 문제 발행
  - 메시지를 발행하는 비즈니스 로직이 클라이언트 라이브러리와 결합됨
  - 메시지 브로커의 클라이언트 라이브러리는 대부분 저수준이고 코드가 긴편 (판박이 코드)
  - 고수준의 상호 작용 스타일은 지원하지 않음
    - 저수준 세부를 감추고 고수준의 상호 작용 스타일을 지원하는 고수준 라이브러리 또는 프레임워크 필요
    - 이벤추에이트 트램 프레임워크 (약팔기 시작)

- 이벤추에이트 트램 중요한 메커니즘
  - 트랜잭셔널 메시징 : 메시지를 DB 트랜잭션의 일부로 발행
  - 중복 메시지 감지 : 이벤추에이트 트램의 메시지 컨슈머는 중복 메시지를 솎아 냄

- 코드 생략 (144P)

#### 기초 메시징
- 클라이언트 코드가 짧음
  - 퍼사드 패턴 비슷한듯

#### 도메인 이벤트 발행
- 비즈니스 객체를 생성, 수정, 삭제 시 애그리거트가 발생시킨 이벤트

#### 커맨드/응답 메시징


## 3.4 비동기 메시징으로 가용성 개선

### 3.4.1 동기 통신으로 인한 가용성 저하

### 3.4.2 동기 상호 작용 제거

#### 비동기 상호 작용 스타일

#### 데이터 복제

#### 응답 반환 후 마무리







