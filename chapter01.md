# 모놀리식 지옥에서 벗어나라
- 음식 배달 업계 인 푸드투고 사례 기반으로 얘기


## 1.1 서서히 모놀리식 지옥에 빠져든다
- 푸드투고 (배민 같은 시스템)
  - FTGO는 배달원과 음식점에 대글 지불
  - 음식점은 FTGO 시스템에서 메뉴를 편집하고 주문 관리


- 푸드투고는 하나의 WAR 파일로 구성된 모놀리스
  - 시간이 갈 수록 애플리케이션 복잡해짐 (스파게티 코드)

### 1.1.1 FTGO 애플리케이션 아키텍처
- FTGO 전체 구조는 헥사고날 아키텍처 사용 (30P)
  - 인바운드 어댑터 : REST API, 웹 UI
  - 아웃바운드 어댑터 : MySQL DB 접속, 외부 클라우드 서비스 호출
  - 비즈니스 로직 : 도메인 객체 컬렉션 모듈

- 논리적으로 (패키지 단위) 모듈화한 아키텍처에도 불구하고 WAR 파일 하나로 패키징 (모놀리식)

### 1.1.2 모놀리식 아키텍처의 장점
- 모놀리식 아키텍처 장점
  - 개발이 간단하다 : IDE 등 개발툴은 단일 애플리케이션 구축에 초첨이 맞추어져 있음
  - 애플리케이션을 쉽게 변경할 수 있다 : 코드, DB 스키마를 변경해도 빌드/배포하기 용이함 (MSA면 여러곳 영향이 있을텐데)
  - 테스트하기 쉽다 : 로컬에서 쉽게 기동 가능
  - 배포하기 쉽다 : 개발자는 서버에 접속하여 톰캣 설치 경로에 WAR 파일을 복사 (배포 자동화 프로세스 이용)
  - 확장하기 쉽다 : 로드 벨런서 뒷면에 인스턴스를 여러개 실행 (스케일 아웃)

- 실상은 시간이 지날 수록, 개발, 테스트, 배포, 확장하기 점점 어려워짐

### 1.1.3 모놀리식 지옥의 실상
- 서비스가 커질 수록 모놀리식 아키텍처가 맞지 않게 됨

- 이 유
  - 너무 복잡해서 개발자가 주눅들다
    - 애플리케이션은 너무 복잡함
    - 내용이 방대해서 버그를 고치고 새 기능을 정확하게 구현하기가 갈수록 힘들어짐
    - 32P 
  - 개발이 더디다
    - 애플리케이션이 너무 커져서 IDE의 실행속도가 느려지고, 빌드 시간도 오래 걸림
    - 코드를 고치고 빌드/실행 후 테스트 까지 너무 많은 시간이 낭비되어 생산성이 떨어짐 
  - 커밋부터 배포에 이르는 길고 험난한 여정
    - 배포팀은 보통 한 달에 한 번정도, 금요일 저녁이나 토요일 밤에 운영에 배포
    - 여러 개발자가 동일 코드베이스에 커밋을 하다 보니 병합 중 컨플릭이 발생할 수 있음
    - 테스트 시간이 너무 김 (실패하면 원인을 찾고 또 조치해야되고)
  - 확장하기 어렵다
    - 애플리케이션은 모듈마다 리소스 요건이 서로 맞지 않아 확장하기 어려움
    - ex) 어떤 모듈은 인-메모리 DB가 적합하고, 어떤 모듈은 CPU 성능이 좋아야 하고 서버 구성 시 리소스 배분을 신경 써야됨
  - 모놀리스는 확실하게 전달하기 어렵다
    - 애플리케이션이 워낙 커서 철저하게 테스트하기 어렵고, 테스트가 부족하면 운영에도 버그가 발생할 가능성이 높음
    - 어떤 모듈에 버그 하나만 있어도 전체 애플리케이션 인스턴스가 내려갈 수 있음
  - 갈수록 한물간 기술 스택에 발목이 붙잡히다
    - 어쩔 수 없이 한물간 기술 스택을 쓸 수 밖에 없음
    - 최신 기술을 사용하기 위해 전체 모놀리식 애플리케이션을 재작성 하는것은 비용도 크고 리스크가 높다 (부분만 변경하기 어려움, 영향도 전체 체크)

## 1.2 이 책의 대상 독자
- 비대해진 애플리케이션 때문에 골머리를 앓고 있는 개발자, 아키텍트, CTO, 기술 책임자

- 엔터프라이즈 애플리케이션 아키텍처 설계에 관한 기본 지식이 필요하며, 다음 항목은 잘 알고 있어야함
  - 3계층 아키텍처
  - 웹 애플리케이션 설계
  - 객체 지향 설계를 응용한 비즈니스 로직 개발
  - RDBMS 사용법 : SQL과 ACID 트랜잭셔 
  - 메시지 브로커와 REST API를 활용한 IPC
  - 인증/인가 등 보안 개념

## 1.3 이 책의 학슴 내용
- 책을 다 읽고 나면
  - 마이크로서비스의 주요 특성과 장단점, 사용 시점
  - 분산 데이터 관리 패턴 (CQRS, 사가)
  - 효과적인 마이크로서비스 테스트 전략
  - 마이크로서비스 배포 옵션
  - 모놀리식 아키텍처를 마이크로서비스 아키텍처로 리팩터링 하는 전략

- 다음과 같은 일을 할 수 있게 됨
  - 마이크로서비스 아키텍처 패턴으로 애플리케이션을 아키텍처링
  - 서비스 비즈니스 로직을 개발
  - 사가를 이용하여 서비스 간 데이터 일관성을 유지
  - 여러 서비스에 걸친 쿼리를 구현
  - 마이크로서비스를 효율적으로 테스트
  - 안전하고, 구성 가능하고, 관측 가능한 운영 레디 서비스를 개발
  - 기존 모놀리식 애플리케이션을 마이크로서비스로 리팩터링

## 1.4 마이그로서비스 아키텍처가 답이다
- 푸드투고 애플리케이션은 점점 몸집이 커지면서 여러 가지 품질 속성이 악화되었고, 소프트웨어 전달 속도(관리성), 확장성, 테스트성이 가장 큰 영향을 받음

- 훈련이 잘된 팀은 모놀리식 지옥에 빠지는 속도를 늦출 수 있지만 규모가 큰 팀에서 여러 사람이 같이 작업할 때 일어나는 문제들은 불가피하고, 쓰지 않는 기술 스택이 쌓여 가는 문제도 어쩔 도리가 없음
  - 결국 마이크로서비스라는 아키텍처로 갈아타야 함

- 마이크로서비스 아키텍처는 경계 컨텍스트(bounded context)가 있는, 느슨하게 결합된 엘리먼트로 구성된 서비스 지향 아키텍처라고 정의

### 1.4.1 확장 큐브와 마이크로서비스
![038_1](https://user-images.githubusercontent.com/7076334/161430773-72339e11-362a-48e0-bceb-b3dbb7f11e8e.jpeg)

- X축 확장 : 다중 인스턴스에 고루 요청 분산 (scale-out)
  - 일반적인 모놀리식 애플리케이션의 확장 수단
  - 로드벨런서 뒷면에 애플리케이션 인스턴스를 N개 띄워 놓고 고루게 분배 (라운드 로빈 방식등)

- Z축 확장 : 요청 속성별 라우팅 (파티션)
  - 다중 인스턴스를 실행하는 것은 X축 확장과 같지만, 인스턴스별로 주어진 데이터 하위 집합만 처리하도록 설정하는 방법
  - 인스턴스 앞면에 위치한 라우터는 요청의 속성에 알맞은 인스턴스로 요청을 라우팅 (ex : userId에 따른 요청 분산)

- Y축 확장 : 기능에 따라 애플리케이션을 서비스로 분해 (마이크로서비스)
  - X,Z 확장은 애플리케이션 능력과 가용성은 개선되지만, 점점 더 복잡해지는 문제는 해결되지 않음
  - 모놀리식 애플리케이션을 여러 서비스로 쪼개는 것
    - 서비스 별로 X,Z 확장도 가능

- 마이크로서비스 아키텍처는 고수준에서 바라보면 하나의 애플리케이션을 여러 서비스로 기능 분해하는 아키텍처 스타일
  - 크기 보다는 집중된 응집된 책임

### 1.4.2 마이크로서비스는 모듈성을 갖고 있다
- 모듈성은 크고 복잡한 애플리케이션을 개발할 때 꼭 필요한 특성
- 마이크로서비스 아키텍처는 서비스를 모듈성의 단위로 사용
  - 다른 서비스를 함부로 침투하지 못하게 API라는 경계선을 갖고 있음
  - 경계선을 가지고 있어서 시간이 지나도 애플리케이션 모듈성을 유지하기가 수월함
  - 독립적으로 배포/확장할 수 있는 부가적인 장점도 있음

### 1.4.3 서비스마다 DB가 따로 있다
- 서비스 별로 각각의 DB를 가지고 있으면 다른 서비스 개발자와 협의하지 않고 서비스 스키마 변경 가능
- 런타임에 서비스는 완전 분리 되어 있기 때문에 다른 서비스가 DB락을 획득해 내 서비스를 블로킹 하는 일은 없음

### 1.4.4 FTGO 마이크로서비스 아키텍처 (42P)
- API 게이트웨이(퍼사드 역할) : 소비자, 배달원의 모바일 앱이 접속하는 REST API 제공
- 음식점 웹 UI : 음식점 주인이 메뉴를 관리하거나 주문을 처리하는 웹 인터페이스 구현
- 주문 : 주문을 관리
- 배달 : 음식점에서 소비자에 이르기까지 주문 배달을 관리
- 음식점 : 음식점 관련 정보를 관리
- 주방 : 주문한 음식을 준비하는 과정을 관리
- 회계 : 과금/지불을 처리
  - 









