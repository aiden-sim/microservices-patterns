# 모놀리식 지옥에서 벗어나라
- 음식 배달 업계 인 푸드투고 사례 기반으로 얘기


## 1.1 서서히 모놀리식 지옥에 빠져든다
- 푸드투고 (배민 같은 시스템)
  - FTGO는 배달원과 음식점에 대글 지불
  - 음식점은 FTGO 시스템에서 메뉴를 편집하고 주문 관리


- 푸드투고는 하나의 WAR 파일로 구성된 모놀리스
  - 시간이 갈 수록 애플리케이션 복잡해짐 (스파게티 코드)

### 1.1.1 FTGO 애플리케이션 아키텍처
- FTGO 전체 구조는 헥사고날 아키텍처 사용 (30P)
  - 인바운드 어댑터 : REST API, 웹 UI
  - 아웃바운드 어댑터 : MySQL DB 접속, 외부 클라우드 서비스 호출
  - 비즈니스 로직 : 도메인 객체 컬렉션 모듈

- 논리적으로 (패키지 단위) 모듈화한 아키텍처에도 불구하고 WAR 파일 하나로 패키징 (모놀리식)

### 1.1.2 모놀리식 아키텍처의 장점
- 모놀리식 아키텍처 장점
  - 개발이 간단하다 : IDE 등 개발툴은 단일 애플리케이션 구축에 초첨이 맞추어져 있음
  - 애플리케이션을 쉽게 변경할 수 있다 : 코드, DB 스키마를 변경해도 빌드/배포하기 용이함 (MSA면 여러곳 영향이 있을텐데)
  - 테스트하기 쉽다 : 로컬에서 쉽게 기동 가능
  - 배포하기 쉽다 : 개발자는 서버에 접속하여 톰캣 설치 경로에 WAR 파일을 복사 (배포 자동화 프로세스 이용)
  - 확장하기 쉽다 : 로드 벨런서 뒷면에 인스턴스를 여러개 실행 (스케일 아웃)

- 실상은 시간이 지날 수록, 개발, 테스트, 배포, 확장하기 점점 어려워짐

### 1.1.3 모놀리식 지옥의 실상
- 서비스가 커질 수록 모놀리식 아키텍처가 맞지 않게 됨

- 이 유
  - 너무 복잡해서 개발자가 주눅들다
    - 애플리케이션은 너무 복잡함
    - 내용이 방대해서 버그를 고치고 새 기능을 정확하게 구현하기가 갈수록 힘들어짐
    - 32P 
  - 개발이 더디다
    - 애플리케이션이 너무 커져서 IDE의 실행속도가 느려지고, 빌드 시간도 오래 걸림
    - 코드를 고치고 빌드/실행 후 테스트 까지 너무 많은 시간이 낭비되어 생산성이 떨어짐 
  - 커밋부터 배포에 이르는 길고 험난한 여정
    - 배포팀은 보통 한 달에 한 번정도, 금요일 저녁이나 토요일 밤에 운영에 배포
    - 여러 개발자가 동일 코드베이스에 커밋을 하다 보니 병합 중 컨플릭이 발생할 수 있음
    - 테스트 시간이 너무 김 (실패하면 원인을 찾고 또 조치해야되고)
  - 확장하기 어렵다
    - 애플리케이션은 모듈마다 리소스 요건이 서로 맞지 않아 확장하기 어려움
    - ex) 어떤 모듈은 인-메모리 DB가 적합하고, 어떤 모듈은 CPU 성능이 좋아야 하고 서버 구성 시 리소스 배분을 신경 써야됨
  - 모놀리스는 확실하게 전달하기 어렵다
    - 애플리케이션이 워낙 커서 철저하게 테스트하기 어렵고, 테스트가 부족하면 운영에도 버그가 발생할 가능성이 높음
    - 어떤 모듈에 버그 하나만 있어도 전체 애플리케이션 인스턴스가 내려갈 수 있음
  - 갈수록 한물간 기술 스택에 발목이 붙잡히다
    - 어쩔 수 없이 한물간 기술 스택을 쓸 수 밖에 없음
    - 최신 기술을 사용하기 위해 전체 모놀리식 애플리케이션을 재작성 하는것은 비용도 크고 리스크가 높다 (부분만 변경하기 어려움, 영향도 전체 체크)

## 1.2 이 책의 대상 독자
- 비대해진 애플리케이션 때문에 골머리를 앓고 있는 개발자, 아키텍트, CTO, 기술 책임자

- 엔터프라이즈 애플리케이션 아키텍처 설계에 관한 기본 지식이 필요하며, 다음 항목은 잘 알고 있어야함
  - 3계층 아키텍처
  - 웹 애플리케이션 설계
  - 객체 지향 설계를 응용한 비즈니스 로직 개발
  - RDBMS 사용법 : SQL과 ACID 트랜잭셔 
  - 메시지 브로커와 REST API를 활용한 IPC
  - 인증/인가 등 보안 개념

## 1.3 이 책의 학슴 내용
- 책을 다 읽고 나면
  - 마이크로서비스의 주요 특성과 장단점, 사용 시점
  - 분산 데이터 관리 패턴 (CQRS, 사가)
  - 효과적인 마이크로서비스 테스트 전략
  - 마이크로서비스 배포 옵션
  - 모놀리식 아키텍처를 마이크로서비스 아키텍처로 리팩터링 하는 전략

- 다음과 같은 일을 할 수 있게 됨
  - 마이크로서비스 아키텍처 패턴으로 애플리케이션을 아키텍처링
  - 서비스 비즈니스 로직을 개발
  - 사가를 이용하여 서비스 간 데이터 일관성을 유지
  - 여러 서비스에 걸친 쿼리를 구현
  - 마이크로서비스를 효율적으로 테스트
  - 안전하고, 구성 가능하고, 관측 가능한 운영 레디 서비스를 개발
  - 기존 모놀리식 애플리케이션을 마이크로서비스로 리팩터링

## 1.4 마이그로서비스 아키텍처가 답이다
- 푸드투고 애플리케이션은 점점 몸집이 커지면서 여러 가지 품질 속성이 악화되었고, 소프트웨어 전달 속도(관리성), 확장성, 테스트성이 가장 큰 영향을 받음

- 훈련이 잘된 팀은 모놀리식 지옥에 빠지는 속도를 늦출 수 있지만 규모가 큰 팀에서 여러 사람이 같이 작업할 때 일어나는 문제들은 불가피하고, 쓰지 않는 기술 스택이 쌓여 가는 문제도 어쩔 도리가 없음
  - 결국 마이크로서비스라는 아키텍처로 갈아타야 함

- 마이크로서비스 아키텍처는 경계 컨텍스트(bounded context)가 있는, 느슨하게 결합된 엘리먼트로 구성된 서비스 지향 아키텍처라고 정의

### 1.4.1 확장 큐브와 마이크로서비스
![038_1](https://user-images.githubusercontent.com/7076334/161430773-72339e11-362a-48e0-bceb-b3dbb7f11e8e.jpeg)

- X축 확장 : 다중 인스턴스에 고루 요청 분산 (scale-out)
  - 일반적인 모놀리식 애플리케이션의 확장 수단
  - 로드벨런서 뒷면에 애플리케이션 인스턴스를 N개 띄워 놓고 고루게 분배 (라운드 로빈 방식등)

- Z축 확장 : 요청 속성별 라우팅 (파티션)
  - 다중 인스턴스를 실행하는 것은 X축 확장과 같지만, 인스턴스별로 주어진 데이터 하위 집합만 처리하도록 설정하는 방법
  - 인스턴스 앞면에 위치한 라우터는 요청의 속성에 알맞은 인스턴스로 요청을 라우팅 (ex : userId에 따른 요청 분산)

- Y축 확장 : 기능에 따라 애플리케이션을 서비스로 분해 (마이크로서비스)
  - X,Z 확장은 애플리케이션 능력과 가용성은 개선되지만, 점점 더 복잡해지는 문제는 해결되지 않음
  - 모놀리식 애플리케이션을 여러 서비스로 쪼개는 것
    - 서비스 별로 X,Z 확장도 가능

- 마이크로서비스 아키텍처는 고수준에서 바라보면 하나의 애플리케이션을 여러 서비스로 기능 분해하는 아키텍처 스타일
  - 크기 보다는 집중된 응집된 책임

### 1.4.2 마이크로서비스는 모듈성을 갖고 있다
- 모듈성은 크고 복잡한 애플리케이션을 개발할 때 꼭 필요한 특성
- 마이크로서비스 아키텍처는 서비스를 모듈성의 단위로 사용
  - 다른 서비스를 함부로 침투하지 못하게 API라는 경계선을 갖고 있음
  - 경계선을 가지고 있어서 시간이 지나도 애플리케이션 모듈성을 유지하기가 수월함
  - 독립적으로 배포/확장할 수 있는 부가적인 장점도 있음

### 1.4.3 서비스마다 DB가 따로 있다
- 서비스 별로 각각의 DB를 가지고 있으면 다른 서비스 개발자와 협의하지 않고 서비스 스키마 변경 가능
- 런타임에 서비스는 완전 분리 되어 있기 때문에 다른 서비스가 DB락을 획득해 내 서비스를 블로킹 하는 일은 없음

### 1.4.4 FTGO 마이크로서비스 아키텍처 (42P)
- API 게이트웨이(퍼사드 역할) : 소비자, 배달원의 모바일 앱이 접속하는 REST API 제공
- 음식점 웹 UI : 음식점 주인이 메뉴를 관리하거나 주문을 처리하는 웹 인터페이스 구현
- 주문 : 주문을 관리
- 배달 : 음식점에서 소비자에 이르기까지 주문 배달을 관리
- 음식점 : 음식점 관련 정보를 관리
- 주방 : 주문한 음식을 준비하는 과정을 관리
- 회계 : 과금/지불을 처리
  - 서비스와 API가 분명하게 정으된 것만 다르고 앞의 모놀리식 모듈에 그대로 대응

### 1.4.5 마이크로서비스 아키텍처와 SOA

|구분|SOA|마이크로서비스|
|------|---|---|
|서비스 간 통신|SOAP, WS* 표준처럼 무거운 프로토콜을 응용한 엔터프라이즈 서비스 버스 중심의 스마트 파이프|REST나 gRPC 처럼 가벼운 프로토콜을 응용한 메시지 브로커 또는 서비스 간 통신 중심의 덤 파이프|
|데이터|전역 데이터 모델 및 공유 DB|서비스 개별 데이터 모델 및 DB|
|주요 사례|대규모 모놀리식 애플리케이션|소규모 서비스|
- 일반적으로 사용하는 기술 스택이 다름
- 데이터 처리 방식도 다름
- 서비스 크기 역시 상이

# 1.5 마이크로서비스 아키텍처의 장단점

## 1.5.1 마이크로서비스 아키텍처의 장점
- 크고 복잡한 애플리케이션을 지속적으로 전달/배포할 수 있음
  - 테스트성 : 지속적 전달/배포를 하려면 자동화 테스트 꼭 필요! 마이크로서비스는 상대적으로 크기가 작아서 자동화 테스트가 쉽고 빠르며, 버그도 적음
  - 배포성 : 독립적으로 배포할 수 있어서 개발자가 자신이 담당한 서비스 변경분을 배포 시, 협의할 필요 없음 (운영 배포 수월함)
  - 자율성, 느슨한 결합 : 팀별 하나 이상의 서비스를 개발/배포 하기 때문에 다른 팀과 독립적으로 개발, 배포, 확장할 수 있어 개발 속도 빠름
  - 비즈니스 이점
    - 제품 오픈 시기를 앞당길 수 있고 고객 피드백에 신속히 대응 가능
    - 작은 모듈 단위를 팀별로 서비스 하다 보니 퀄리티 향상?


- 서비스 규모가 작아 관리하기 쉬움
  - 코드베이스가 작으면 IDE도 느려지지 않아서 개발자 생산성 올라감
  - 규모가 작기 때문에 배포 과정 역시 더 빠르고 생산적 (46P)

- 서비스를 독립적으로 배포/확장할 수 있음
  - 독립적으로 X(scale-out) / Z(파티셔닝) 확장 가능
  - 서비스마다 다르한 리소스 정의 가능 (CPU, 메모리)

- 결함 격리가 잘됨
  - 특정 서비스에서 메모리 누수가 발생되도, 다른 서비스에 영향 없음
  - 모놀리식은 전체 시스템 영향

- 새로운 기술을 실험하고 도입하기 쉬움
  - 새로운 서비스를 개발할 때 그 서비스에 가장 알맞은 언어와 프레임워크를 자유롭게 선택 가능
  - 서비스 규모가 작기 때문에 더 나은 언어와 기술로 재작성할 수 있음

## 1.5.2 마이크로서비스 아키텍처의 단점
- 딱 맞는 서비스를 찾기가 쉽지 않음 (서비스 규모를 얘기 하는듯)
  - 시스템을 잘못 분해할 경우, 모놀리식/마이크로서비스 아키텍처의 단점만 있는 분산 모놀리스를 구축하게 됨

- 분산 시스템은 너무 복잡해서 개발, 테스트, 배포가 어려움
  - IPC 호출은 메서드 호출보다 복잡함
  - 사용 불능 또는 지연 시간이 긴 원격 서비스, 부분 실패한 서비스를 처리할 수 있게 설계
  - 서비스 별로 DB가 다르기 때문에 다중 DB에 대해 조회하고 트랜잭션 구현하는 일이 어려움 (사가로 일관성 유지)
  - 단순 쿼리로 여러 서비스 데이터 조회가 힘듬 API를 조합 하거나 (graphQL) CQRS 뷰로 쿼리 (레플리카)
  - IDE등 각종 툴 역시 모놀리식 애플리케이션 개발에 초첨이 맞춰져 있음
  - 여러 서비스 연관된 테스트를 자동화 하는 것도 쉼지 않음
  - 운영 복잡도 역시 가중 (종류가 다른 서비스들)


- 여러 서비스에 걸친 기능은을 배포 시, 잘 조정해야 됨
  - 서비스 간 디펜던시에 따라 서비스 배포 계획을 빈틈없이 수립해야 됨

- 마이크로서비스 아키텍처 도입 시점을 결정하기 어려움
  - 초기 버전 시 마이크로서비스 아키텍처를 사용해서 해결할 이슈가 거의 없음
  - 복잡성을 다루는 문제가 중요해지는 시점에 마이크로서비스로 분해하는 것은 바람직함
  
- 완벽한 결정은 없다. 트레이드오프가 있다.

## 1.6 마이크로서비스 아키텍처 패턴 언어
- 아키텍처와 설계는 결정하기 나름 (트레이드오프)
  - 더 나은 결정을 내리는 좋은 방법은 패턴 언어를 사용

### 1.6.1 마이크로서비스 아키텍처도 만병통치약은 아니다

### 1.6.2 패턴 및 패턴 언어

### 1.6.3 마이크로서비스 아키텍처 패턴 언어 개요


## 1.7 마이크로서비스 너머: 프로세스와 조직








