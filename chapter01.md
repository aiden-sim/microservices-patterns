# 모놀리식 지옥에서 벗어나라
- 음식 배달 업계 인 푸드투고 사례 기반으로 얘기


## 1.1 서서히 모놀리식 지옥에 빠져든다
- 푸드투고 (배민 같은 시스템)
  - FTGO는 배달원과 음식점에 대 지불
  - 음식점은 FTGO 시스템에서 메뉴를 편집하고 주문 관리


- 푸드투고는 하나의 WAR 파일로 구성된 모놀리스
  - 시간이 갈 수록 애플리케이션 복잡해짐 (스파게티 코드)

### 1.1.1 FTGO 애플리케이션 아키텍처
- FTGO 전체 구조는 헥사고날 아키텍처 사용 (30P)
  - 인바운드 어댑터 : REST API, 웹 UI
  - 아웃바운드 어댑터 : MySQL DB 접속, 외부 클라우드 서비스 호출
  - 비즈니스 로직 : 도메인 객체 컬렉션 모듈

- 논리적으로 (패키지 단위) 모듈화한 아키텍처에도 불구하고 WAR 파일 하나로 패키징 (모놀리식)

### 1.1.2 모놀리식 아키텍처의 장점
- 모놀리식 아키텍처 장점
  - 개발이 간단하다 : IDE 등 개발툴은 단일 애플리케이션 구축에 초첨이 맞추어져 있음
  - 애플리케이션을 쉽게 변경할 수 있다 : 코드, DB 스키마를 변경해도 빌드/배포하기 용이함 (MSA면 여러곳 영향이 있을텐데)
  - 테스트하기 쉽다 : 로컬에서 쉽게 기동 가능
  - 배포하기 쉽다 : 개발자는 서버에 접속하여 톰캣 설치 경로에 WAR 파일을 복사 (배포 자동화 프로세스 이용)
  - 확장하기 쉽다 : 로드 벨런서 뒷면에 인스턴스를 여러개 실행 (스케일 아웃)

- 실상은 시간이 지날 수록, 개발, 테스트, 배포, 확장하기 점점 어려워짐

### 1.1.3 모놀리식 지옥의 실상
- 서비스가 커질 수록 모놀리식 아키텍처가 맞지 않게 됨

- 이 유
  - 너무 복잡해서 개발자가 주눅들다
    - 애플리케이션은 너무 복잡함
    - 내용이 방대해서 버그를 고치고 새 기능을 정확하게 구현하기가 갈수록 힘들어짐
    - 32P 
  - 개발이 더디다
    - 애플리케이션이 너무 커져서 IDE의 실행속도가 느려지고, 빌드 시간도 오래 걸림
    - 코드를 고치고 빌드/실행 후 테스트 까지 너무 많은 시간이 낭비되어 생산성이 떨어짐 
  - 커밋부터 배포에 이르는 길고 험난한 여정
    - 배포팀은 보통 한 달에 한 번정도, 금요일 저녁이나 토요일 밤에 운영에 배포
    - 여러 개발자가 동일 코드베이스에 커밋을 하다 보니 병합 중 컨플릭이 발생할 수 있음
    - 테스트 시간이 너무 김 (실패하면 원인을 찾고 또 조치해야되고)
  - 확장하기 어렵다
    - 애플리케이션은 모듈마다 리소스 요건이 서로 맞지 않아 확장하기 어려움
    - ex) 어떤 모듈은 인-메모리 DB가 적합하고, 어떤 모듈은 CPU 성능이 좋아야 하고 서버 구성 시 리소스 배분을 신경 써야됨
  - 모놀리스는 확실하게 전달하기 어렵다
    - 애플리케이션이 워낙 커서 철저하게 테스트하기 어렵고, 테스트가 부족하면 운영에도 버그가 발생할 가능성이 높음
    - 어떤 모듈에 버그 하나만 있어도 전체 애플리케이션 인스턴스가 내려갈 수 있음
  - 갈수록 한물간 기술 스택에 발목이 붙잡히다
    - 어쩔 수 없이 한물간 기술 스택을 쓸 수 밖에 없음
    - 최신 기술을 사용하기 위해 전체 모놀리식 애플리케이션을 재작성 하는것은 비용도 크고 리스크가 높다 (부분만 변경하기 어려움, 영향도 전체 체크)

## 1.2 이 책의 대상 독자
- 비대해진 애플리케이션 때문에 골머리를 앓고 있는 개발자, 아키텍트, CTO, 기술 책임자

- 엔터프라이즈 애플리케이션 아키텍처 설계에 관한 기본 지식이 필요하며, 다음 항목은 잘 알고 있어야함
  - 3계층 아키텍처
  - 웹 애플리케이션 설계
  - 객체 지향 설계를 응용한 비즈니스 로직 개발
  - RDBMS 사용법 : SQL과 ACID 트랜잭셔 
  - 메시지 브로커와 REST API를 활용한 IPC
  - 인증/인가 등 보안 개념

## 1.3 이 책의 학습 내용
- 책을 다 읽고 나면
  - 마이크로서비스의 주요 특성과 장단점, 사용 시점
  - 분산 데이터 관리 패턴 (CQRS, 사가)
  - 효과적인 마이크로서비스 테스트 전략
  - 마이크로서비스 배포 옵션
  - 모놀리식 아키텍처를 마이크로서비스 아키텍처로 리팩터링 하는 전략

- 다음과 같은 일을 할 수 있게 됨
  - 마이크로서비스 아키텍처 패턴으로 애플리케이션을 아키텍처링
  - 서비스 비즈니스 로직을 개발
  - 사가를 이용하여 서비스 간 데이터 일관성을 유지
  - 여러 서비스에 걸친 쿼리를 구현
  - 마이크로서비스를 효율적으로 테스트
  - 안전하고, 구성 가능하고, 관측 가능한 운영 레디 서비스를 개발
  - 기존 모놀리식 애플리케이션을 마이크로서비스로 리팩터링

## 1.4 마이그로서비스 아키텍처가 답이다
- 푸드투고 애플리케이션은 점점 몸집이 커지면서 여러 가지 품질 속성이 악화되었고, 소프트웨어 전달 속도(관리성), 확장성, 테스트성이 가장 큰 영향을 받음

- 훈련이 잘된 팀은 모놀리식 지옥에 빠지는 속도를 늦출 수 있지만 규모가 큰 팀에서 여러 사람이 같이 작업할 때 일어나는 문제들은 불가피하고, 쓰지 않는 기술 스택이 쌓여 가는 문제도 어쩔 도리가 없음
  - 결국 마이크로서비스라는 아키텍처로 갈아타야 함

- 마이크로서비스 아키텍처는 경계 컨텍스트(bounded context)가 있는, 느슨하게 결합된 엘리먼트로 구성된 서비스 지향 아키텍처라고 정의

### 1.4.1 확장 큐브와 마이크로서비스
![038_1](https://user-images.githubusercontent.com/7076334/161430773-72339e11-362a-48e0-bceb-b3dbb7f11e8e.jpeg)

- X축 확장 : 다중 인스턴스에 고루 요청 분산 (scale-out)
  - 일반적인 모놀리식 애플리케이션의 확장 수단
  - 로드벨런서 뒷면에 애플리케이션 인스턴스를 N개 띄워 놓고 고루게 분배 (라운드 로빈 방식등)

- Z축 확장 : 요청 속성별 라우팅 (파티션)
  - 다중 인스턴스를 실행하는 것은 X축 확장과 같지만, 인스턴스별로 주어진 데이터 하위 집합만 처리하도록 설정하는 방법
  - 인스턴스 앞면에 위치한 라우터는 요청의 속성에 알맞은 인스턴스로 요청을 라우팅 (ex : userId에 따른 요청 분산)

- Y축 확장 : 기능에 따라 애플리케이션을 서비스로 분해 (마이크로서비스)
  - X,Z 확장은 애플리케이션 능력과 가용성은 개선되지만, 점점 더 복잡해지는 문제는 해결되지 않음
  - 모놀리식 애플리케이션을 여러 서비스로 쪼개는 것
    - 서비스 별로 X,Z 확장도 가능

- 마이크로서비스 아키텍처는 고수준에서 바라보면 하나의 애플리케이션을 여러 서비스로 기능 분해하는 아키텍처 스타일
  - 크기 보다는 집중된 응집된 책임

### 1.4.2 마이크로서비스는 모듈성을 갖고 있다
- 모듈성은 크고 복잡한 애플리케이션을 개발할 때 꼭 필요한 특성
- 마이크로서비스 아키텍처는 서비스를 모듈성의 단위로 사용
  - 다른 서비스를 함부로 침투하지 못하게 API라는 경계선을 갖고 있음
  - 경계선을 가지고 있어서 시간이 지나도 애플리케이션 모듈성을 유지하기가 수월함
  - 독립적으로 배포/확장할 수 있는 부가적인 장점도 있음

### 1.4.3 서비스마다 DB가 따로 있다
- 서비스 별로 각각의 DB를 가지고 있으면 다른 서비스 개발자와 협의하지 않고 서비스 스키마 변경 가능
- 런타임에 서비스는 완전 분리 되어 있기 때문에 다른 서비스가 DB락을 획득해 내 서비스를 블로킹 하는 일은 없음

### 1.4.4 FTGO 마이크로서비스 아키텍처 (42P)
- API 게이트웨이(퍼사드 역할) : 소비자, 배달원의 모바일 앱이 접속하는 REST API 제공
- 음식점 웹 UI : 음식점 주인이 메뉴를 관리하거나 주문을 처리하는 웹 인터페이스 구현
- 주문 : 주문을 관리
- 배달 : 음식점에서 소비자에 이르기까지 주문 배달을 관리
- 음식점 : 음식점 관련 정보를 관리
- 주방 : 주문한 음식을 준비하는 과정을 관리
- 회계 : 과금/지불을 처리
  - 서비스와 API가 분명하게 정으된 것만 다르고 앞의 모놀리식 모듈에 그대로 대응

### 1.4.5 마이크로서비스 아키텍처와 SOA

|구분|SOA|마이크로서비스|
|------|---|---|
|서비스 간 통신|SOAP, WS* 표준처럼 무거운 프로토콜을 응용한 엔터프라이즈 서비스 버스 중심의 스마트 파이프|REST나 gRPC 처럼 가벼운 프로토콜을 응용한 메시지 브로커 또는 서비스 간 통신 중심의 덤 파이프|
|데이터|전역 데이터 모델 및 공유 DB|서비스 개별 데이터 모델 및 DB|
|주요 사례|대규모 모놀리식 애플리케이션|소규모 서비스|
- 일반적으로 사용하는 기술 스택이 다름
- 데이터 처리 방식도 다름
- 서비스 크기 역시 상이

# 1.5 마이크로서비스 아키텍처의 장단점

## 1.5.1 마이크로서비스 아키텍처의 장점
- 크고 복잡한 애플리케이션을 지속적으로 전달/배포할 수 있음
  - 테스트성 : 지속적 전달/배포를 하려면 자동화 테스트 꼭 필요! 마이크로서비스는 상대적으로 크기가 작아서 자동화 테스트가 쉽고 빠르며, 버그도 적음
  - 배포성 : 독립적으로 배포할 수 있어서 개발자가 자신이 담당한 서비스 변경분을 배포 시, 협의할 필요 없음 (운영 배포 수월함)
  - 자율성, 느슨한 결합 : 팀별 하나 이상의 서비스를 개발/배포 하기 때문에 다른 팀과 독립적으로 개발, 배포, 확장할 수 있어 개발 속도 빠름
  - 비즈니스 이점
    - 제품 오픈 시기를 앞당길 수 있고 고객 피드백에 신속히 대응 가능
    - 작은 모듈 단위를 팀별로 서비스 하다 보니 퀄리티 향상?


- 서비스 규모가 작아 관리하기 쉬움
  - 코드베이스가 작으면 IDE도 느려지지 않아서 개발자 생산성 올라감
  - 규모가 작기 때문에 배포 과정 역시 더 빠르고 생산적 (46P)

- 서비스를 독립적으로 배포/확장할 수 있음
  - 독립적으로 X(scale-out) / Z(파티셔닝) 확장 가능
  - 서비스마다 다르한 리소스 정의 가능 (CPU, 메모리)

- 결함 격리가 잘됨
  - 특정 서비스에서 메모리 누수가 발생되도, 다른 서비스에 영향 없음
  - 모놀리식은 전체 시스템 영향

- 새로운 기술을 실험하고 도입하기 쉬움
  - 새로운 서비스를 개발할 때 그 서비스에 가장 알맞은 언어와 프레임워크를 자유롭게 선택 가능
  - 서비스 규모가 작기 때문에 더 나은 언어와 기술로 재작성할 수 있음

## 1.5.2 마이크로서비스 아키텍처의 단점
- 딱 맞는 서비스를 찾기가 쉽지 않음 (서비스 규모를 얘기 하는듯)
  - 시스템을 잘못 분해할 경우, 모놀리식/마이크로서비스 아키텍처의 단점만 있는 분산 모놀리스를 구축하게 됨

- 분산 시스템은 너무 복잡해서 개발, 테스트, 배포가 어려움
  - IPC 호출은 메서드 호출보다 복잡함
  - 사용 불능 또는 지연 시간이 긴 원격 서비스, 부분 실패한 서비스를 처리할 수 있게 설계
  - 서비스 별로 DB가 다르기 때문에 다중 DB에 대해 조회하고 트랜잭션 구현하는 일이 어려움 (사가로 일관성 유지)
  - 단순 쿼리로 여러 서비스 데이터 조회가 힘듬 API를 조합 하거나 (graphQL) CQRS 뷰로 쿼리 (레플리카)
  - IDE등 각종 툴 역시 모놀리식 애플리케이션 개발에 초첨이 맞춰져 있음
  - 여러 서비스 연관된 테스트를 자동화 하는 것도 쉼지 않음
  - 운영 복잡도 역시 가중 (종류가 다른 서비스들)


- 여러 서비스에 걸친 기능은을 배포 시, 잘 조정해야 됨
  - 서비스 간 디펜던시에 따라 서비스 배포 계획을 빈틈없이 수립해야 됨

- 마이크로서비스 아키텍처 도입 시점을 결정하기 어려움
  - 초기 버전 시 마이크로서비스 아키텍처를 사용해서 해결할 이슈가 거의 없음
  - 복잡성을 다루는 문제가 중요해지는 시점에 마이크로서비스로 분해하는 것은 바람직함
  
- 완벽한 결정은 없다. 트레이드오프가 있다.

## 1.6 마이크로서비스 아키텍처 패턴 언어
- 아키텍처와 설계는 결정하기 나름 (트레이드오프)
  - 더 나은 결정을 내리는 좋은 방법은 패턴 언어를 사용

### 1.6.1 마이크로서비스 아키텍처도 만병통치약은 아니다
- 소프트웨어 공학에 만병통치약 따위는 없음
- 마이크로서비스 역시 만병통치약이 아님
- 기술을 패턴 포맷으로 나타내면 자연히 그 단점도 드러나게 됨

### 1.6.2 패턴 및 패턴 언어
- 패턴은 특정한 상황에서 발생한 문제에 대한 재사용 가능한 해법
- 패턴 언어는 특정 영역 내부에서 문제를 해결하는 연관된 패턴의 집합
- 패턴과 패턴 언어의 역사를 설명

- 사용 패턴의 구조 (세 부분)
  - 강제 조항
  - 결과 맥락
  - 연관 패턴

- 강제 조항 : 문제 해결을 위해 반드시 처리해야 할 이슈
  - 문제를 해결하고자 할 떄 반드시 처리해야 할 강제 조항
  - 상충 하는 강제 조항도 있어서 모든 조항을 전부 충족할 수는 없고, 어느 조항이 더 중요한지 맥락에 따라 다르므로 우선순위를 정해야 함
  - ex) 코드는 이해하기 쉬워야 하는 동시에 성능도 우수해야 함

- 결과 맥락 : 패턴 적용 결과
  - 패턴을 적용한 결과를 다음 세 부분으로 기술
    - 장점 : 패턴의 좋은 점
    - 단점 : 패턴의 나쁜 점
    - 이슈 : 패턴 적용 시 발생한 새로운 문제점  

- 연관 패턴 : 다섯 가지 관계 유형
  - 한 패턴과 다른 패턴의 관계를 기술하는 영역
    - 선행자 : 이 패턴을 필요하게 만든 선행 패턴
      - 마이크로서비스는 다른 패턴의 선행자 
    - 후행자 : 이 패턴으로 이야기된 이슈를 해결하는 패턴
      - 마이크로서비스 => 서비스 디스커버리 패턴, 회로 차단기 패턴 등 
    - 대안 : 이 패턴의 대체 솔루션을 제공하는 패턴
      - 모놀리식 <=> 마이크로서비스 
    - 일반화 : 문제를 해결하는 일반적인 솔루션에 해당하는 패턴
    - 세분화 : 특정 패턴을 더 세부적으로 나타낸 형태

  - P53 그림 참고

### 1.6.3 마이크로서비스 아키텍처 패턴 언어 개요
- 마이크로서비스 아키텍처 패턴 언어는 전체 애플리케이션을 마이크로서비스 아키텍처로 구성할 때 유용한 패턴의 모음집 

- ![스크린샷 2022-04-04 오후 6 58 07](https://user-images.githubusercontent.com/7076334/161520914-abf958c3-fb64-4732-9833-d012bf5755ad.png)
  - 마이크로서비스 아키텍처 패턴 언어를 고수준에서 바라본 그림
  - 왼쪽은 애플리케이션 아키텍처 패턴(모놀리식/마이크로서비스 아키텍처), 나머지 그룹은 마이크로서비스 아키텍처 패턴의 문제를 해결하는 패턴

  - 패턴든 다시 세 계층으로 분류
    - 인프라 패턴 : 주로 개발 영역 밖의 인프라 문제를 해결
    - 애플리케이션 인프라 : 개발에도 영향을 미치는 인프라 문제를 해결
    - 애플리케이션 패턴 : 개발자가 맞닥뜨리는 문제를 해결 (디자인 패턴을 얘기 하는듯?)


- 애플리케이션을 여러 서비스로 분해하는 패턴 (자세한건 2장)
  - 비즈니스 능력에 따라 서비스를 구성하는 방법
  - DDD 하위 도메인에 따라 서비스를 구성하는 방법

- 통신 패턴
  - 마이크로서비스는 기본적으로 분산 시스템이기 때문에 프로세스 간 통신이 중요. 통신 패턴을 크게 다섯가지로 정의
    - 통신 스타일 : 어떤 종류의 IPC를 사용하는가?
    - 디스커버리 : 서비스 클라이언트는 서비스 인스턴스의 IP 주소를 어떻게 가져오는가?
    - 신뢰성 : 서비스 불능 시 서비스 간 통신의 신뢰성은 어떻게 보장되는가?
    - 트랜잭셔널 메시징 : 비즈니스 데이터를 업데이트하는 DB 트랜잭션에 메시지를 송신하고 이벤트를 발행하는 행위를 어떻게 통합하는가?
    - 외부 API : 애플리케이션 클라이언트는 서비스와 어떻게 통신하는가?

- 트랜잭션 관리를 위한 데이터 일관성 패턴
  - 분산 트랜잭션(2PC)은 요즘 애플리케이션에 안맞는 방법이라 사가 패턴에 따라 일관성 유지

- 데이터 쿼리 패턴
  - 서비스 별로 DB를 두면 서비스가 소유한 데이터를 조인하는 쿼리도 문제
  - API 조합 패턴 : 하나 이상의 서비스를 호출해서 그 결과를 조합
  - CQRS : 하나 이상의 데이터 레플리카를 유지해서 쉽게 쿼리하는 방식

- 서비스 배포 패턴
  - 모놀리스는 그래도 배포 애플리케이션이 하나 있어서 무척 직관적
  - 마이크로서비스는 다양한 언어와 프레임워크로 구현된 수십~수백 개의 서비스로 이루어져 있어 배포 작업이 훨씬 더 복잡함
    - 고도로 자동화한 배포 인프라가 필요
    - 개발자가 단순한 UI로 서비스를 배포/관리하고, 가상 머신(VM), 컨테이너, 서버리스 기술을 응용한 배포 플랫폼이 바람직함 

- 관측성 패턴 : 애플리케이션 동작 파악
  - 모놀리식은 요청이 비교적 단순하고 알기 쉽게 처리되므로 비교적 트러블 슈팅이 수월한 편
  - 마이크로서비스는 로그 파일 하나만으로는 원인을 파악할 수 없고 문제의 원인을 찾기 복잡함
  - 다음과 같은 패턴이 필요
    - 헬스 체크 API : 서비스 헬스를 반환하는 끝점을 표출
    - 로그 수집 : 서비스 내역을 기록하고 중앙 로깅 서버에 로그를 출력하여 검색/경고 기능을 제공
    - 분산 추적 : 각 외부 요청마다 ID를 부여하여 서비스를 통과하는 과정을 추적 (집킨)
    - 예외 추적 : 예외가 발생하면 예외 추적 서비스에 보고
    - 애플리케이션 지표 : 카운터, 게이지 등의 지표를 측정하여 지표 서버에 표출
    - 감사 로깅 : 사용자가 한 일을 기록  

- 서비스 테스트 자동화 패턴
  - 마이크로서비스는 단위 서비스 크기가 비교적 작아서 테스트하기 쉽지만, 서로 다른 여러 서비스가 조화롭게 잘 작동되는지 테스트 하는게 중요 (통합 테스트)
  - 다음과 같은 테스트 필요
    - 컨슈머 주도 계약 테스트 : 클라이언트가 의도한 대로 서비스가 동작하는지 확인
    - 컨슈머 쪽 계약 테스트 : 클라이언트와 서비스가 상호 통신 가능한지 확인
    - 서비스 컴포넌트 테스트 : 서비스를 따로 따로 테스트

- 횡단 관심사 처리 패턴
  - 신규 서비스 구축 시 횡당(공통) 관심사를 처음부터 개발하려면 시간이 너무 많이 걸림
  - 따라서 횡단 관심사를 처리하는 프레임워크에서 마이크로서비스 섀시 패턴을 적용하여 서비스를 구축

- 보안 패턴
  - 가장 일반적인 솔루션은 JWT 같은 액세스 토큰 패턴 적용
  - API 게이트웨이는 액세스 토큰을 서비스에 건네고 서비스는 토큰 확인 후 사용자 정보를 조회

## 1.7 마이크로서비스 너머: 프로세스와 조직
- 올바른 아키텍처뿐만 아니라 올바른 조직, 올바른 개발/배포 프로세스도 수립되어야 소프트웨어 개발에 성공할 수 있다. (P62)

### 1.7.1 소프트웨어 개발/전달 조직
- 규모가 큰 팀은 효율이 떨어져서 여러 팀으로 나누는 것이 좋다. (8 ~ 12명)
- 비즈니스 관점에서 팀의 목표는 명확함. 어떤 기능이나 비즈니스 능력이 구현된 하나 이상의 서비스를 개발/운영하는 것

- 거대한 한 팀보다는 작은 여러 팀의 움직임이 훨씬 바름
- 마이크로서비스는 각 팀마다 굳이 다른 팀과 협의할 필요 없이 독립적으로 서비스를 개발, 배포, 확장할 수 있다.

- 개발 조직도 확장성이 좋아짐
- 팀은 서로 느슨하게 결합되어 있으므로 대규모 팀의 소통 오버헤드가 발생할 일은 없으며, 생산성에는 아무런 영향을 끼치지 않고 인원을 보강할 수 있음

### 1.7.2 소프트웨어 개발/전달 프로세스
- 애자일 개발 프로세스를 도입하고 스크럽, 칸반 등을 실천해야 함
- 데브옵스의 일부인 지속적 전달/배포를 실천하면 좋음!
  - 지속적 전달의 핵심은 언제라도 릴리스 할 수 있는 능력 (높은 수준의 자동화는 필수)
  - 지속적 배포를 실천하는 고성능 조직은 하루에 운영 배포를 여러 차례 수행하면서도 중단 사고는 거의 없고, 사고가 발생해도 신속하게 복구함

### 1.7.3 마이크로서비스를 받아들이는 인간적 요소
- 마이크로서비스를 도입하면 아키텍처, 조직, 개발 프로세스 모두 변화함. 인간의 근무 환경도 달라질 것임

- 사람들이 변화에 대해 감정적으로 대응하는 3단계
  - 1) 끝나다, 빼앗기다, 놓아주다 : 안락한 영역에서 강제로 내쫒기게 되었을 때 느끼는 감정적인 격변과 저항 기간
  - 2) 중립 지대 : 옛 작업 방식과 새 작업 방식 사이의 중간 단계. 혼란스럽지만 어떻게든 새로운 방식을 배우려함
  - 3) 새 출발 : 사람들이 새로운 작업 방식을 열심히 받아들이고 그 혜택을 몸소 경험하기 시작하는 최종 단계

