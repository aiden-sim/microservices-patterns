# 마이크로서비스 테스트 2부
- 통합, 컴포넌트, 종단 간 테스트를 알아보자


## 10.1 통합 테스트 작성
- 405P MSA 구조는 (REST API, 이벤트 채널 이용) 서비스를 전부 띄어 놓고 API를 호출해 보는 종단 테스트가 확실하지만, 느리고 취약하며 비용이 많이 듬
  - 통합 텟트트를 작성하는 것이 좋다.

- 통합 테스트 전략
  - 1) 각 서비스의 어댑터를 테스트
    - ex) OrderRepository, OrderDomainEventPublisher 직접 테스트 
  - 2) 계약을 활용하는 전략 (컨슈머 계약) 
    - ex) 커슈머/프로바이더 둘 다 테스트해서 서로 바라보는 API가 일치하는지 확인
    - 소비자 쪽 테스트 : 컨슈머의 어댑터에 대한 테스트. 계약을 이용하여 프로바이더를 모킹한 스텁을 구성할 수 있어서 컨슈머만으로 통합 테스트를 작성
    - 프로바이더 쪽 테스트 : 프로바이더의 어댑터에 대한 테스트. 어댑터의 디펜던시를 목으로 잡아 놓고 계약을 이용하여 어댑터 테스트

### 10.1.1 통합 테스트: 영속화
- 영속화 통합 테스트의 절차
  - 설정(setup) : DB 스키마를 생성하고 기지의 상태로 초기화하는 DB를 설정
  - 실행(execute) : DB 작업을 수행
  - 확인(verify) : DB 상태, 그리고 DB에서 조회한 객체를 단언
  - 정리(teardown) : 설정 단계에서 시작한 트랜잭션을 롤백하는 등 DB에 변경한 내용을 언두해야 할 경우 사용 

- DB 프로비저닝을 어떻게 할까?
 - 도커를 활용

- DBUnit 이용

### 10.1.2 통합 테스트: REST 요청/응답형 상호 작용
- 스프링 클라우드 컨트랙트를 이용해서 REST 기반의 상호 작용을 테스트

- 소비자쪽 API 게이트웨이 통합 테스트는 계약을 이용하여 주문 서비스의 동작을 흉내낸 HTTP 스텁 서버를 구성
- 계약의 요청은 API 게이트웨이가 스텁에 어떤 HTTP 요청을 하는지 기술하고, 계약의 응답은 스텁이 API 게이트웨이에 어떤 응답을 돌려주는지 기술

#### REST API 계약 예제
```
org.springframework.cloud.contract.spec.Contract.make {
  request {
    method 'GET'
    url '/orders/1223232'

  }
  response {
    status 200

    headers {
      header('Content-Type': 'application/json;charset=UTF-8')
    }
    body('''{"orderId" : "1223232", "state" : "APPROVAL_PENDING"}''')
}
```
- 계약 요청에는 HTTP 메서드 경로, 헤더(옵션)
- 계약 응답에는 HTTP 상태 코드, 헤더(옵션), 본문(해당 시)

#### 컨슈머 주도 계약 통합 테스트: 주문 서비스
- 스프링 클라우드 컨트랙트로 코드-생성된 테스트 클래스의 추상 기초 클래스 HttpBase는 테스트 설정 단계를 담당
 - 이 클래스는 목 디펜던시가 주입된 컨트롤러를 생성하고, 이 목이 컨트롤러가 기대한 응답을 만들어 내도록 설정

#### 소비자 쪽 통합 테스트: API 게이트웨이의 OrderServiceProxy
- 10-4 예제에서 '@AutoConfigureStubRunnder'는 스프릥 클라우드 컨트랙트가 랜덤 포트에 와이어목 서버를 계약 내용대로 구성/실행하도록 지시하는 애너테이션
- 각 테스트 메서드는 OrderServiceProxy를 호출해서 정확한 값이 반환되는지, 아니면 기대한 예외가 던져지는지 확인

### 10.1.3 통합 테스트: 발행/구독 스타일 상호 작용
- 상호 작용은 계약 세트로 정의하는 것은 같지만, 각 계약마다 도메인 이벤트를 지정하는 차이점이 있음

- 컨슈머 쪽 테스트는 각 계약에 지정된 이벤트를 발행하며 OrderHistoryEventHandler가 목 디펜던시를 올바르게 호출하는지 확인
- 프로바이더 쪽은 스프링 클라우드 컨트랙트가 MessagingBase를 상속한 테스트 클래스를 코드-생성함
  - 각 테스트 메서드가 MessagingBase에 있는 훅 메서드를 호출하면 서비스에 의해 이벤트 발행이 트리거됨 

#### OrderCreated 이벤트 발행 계약
- 예제 10-5 계약의 두 가지 주요 엘리먼트
  - label : 컨슈머 테스트에서 스프링 컨트랙트가 이벤트 발행을 트리거하기 위해 사용하는 엘리먼트
  - triggeredBy : 코드-생성된 테스트 메서드가 이벤트 발행을 트리거하기 위해 호출하는 상위 클래스의 메서드명

#### 컨슈머 주도 계약 테스트: 주문 서비스
- 주문 서비스의 프로바이더 쪽 테스트는 컨슈머 주도 계약 통합 테스트

#### 소비자 쪽 계약 테스트: 주문 이력 서비스
- 주문 이력 서비스는 주문 서비스가 발행한 이벤트를 소비하는 서비스

### 10.1.4 통합 계약 테스트: 비동기 요청/응답 상호 작용
- 비동기 요청/응답 상호 작용에는 커맨드를 전송하는 서비스인 요청자(requestor), 커맨드 처리 후 응답을 반환하는 서비스인 응답자(replier)가 있음
- 요청자와 응답자가 바라보는 커맨드 메시지 채널명과 커맨드/응답 메시지의 구조는 반드시 일치해야 함

- 비동기 요청/응답 상호 작용의 통합 테스트는 REST 테스트와 비슷하며, 요청/응답 대신 입출력 메시지를 지정하는 것만 다름

- 스프링 클라우드 컨트랙트는 프로바이더 쪽 테스트를 코드-생성함
  - 각 테스트 메서드는 하나의 계약에 대응되며, 계약의 입력 메시지를 커맨드 메시지로 전송하고 그 응답 메시지가 계약의 출력 메시지와 일치하는지 테스 

#### 비동기 요청/응답 계약 예제
- 입출력 메시지 모두 메시지 채널, 본문, 헤더가 지정되어 있고, 프로바이더 관점에서 명명 규칙을 따랐음

#### 소비자 쪽 계약 통합 테스트: 비동기 요청/응답 상호 작용
- 테스트는 서비스의 메시징 프록시를 호출해서 메시징 프록시가 계약대로 커맨드 메시지를 보내는지, 그리고 프록시가 응답 메시지를 적절히 처리하는지, 두 가지를 확인

#### 프로바이더 쪽, 컨슈머 주도 계약 테스트: 비동기 요청/응답 상호 작용
- 프로바이더 쪽 통합 테스트는 프로바이더가 응답을 올바르게 전송해서 커맨드 메시지를 처리하는지 확인해야 함

## 10.2 컴포넌트 테스트 개발


## 10.3 종단 간 테스트 작성

## 10.4 마치며



