# 마이크로서비스 테스트 2부
- 통합, 컴포넌트, 종단 간 테스트를 알아보자


## 10.1 통합 테스트 작성
- 405P MSA 구조는 (REST API, 이벤트 채널 이용) 서비스를 전부 띄어 놓고 API를 호출해 보는 종단 테스트가 확실하지만, 느리고 취약하며 비용이 많이 듬
  - 통합 텟트트를 작성하는 것이 좋다.

- 통합 테스트 전략
  - 1) 각 서비스의 어댑터를 테스트
    - ex) OrderRepository, OrderDomainEventPublisher 직접 테스트 
  - 2) 계약을 활용하는 전략 (컨슈머 계약) 
    - ex) 커슈머/프로바이더 둘 다 테스트해서 서로 바라보는 API가 일치하는지 확인
    - 소비자 쪽 테스트 : 컨슈머의 어댑터에 대한 테스트. 계약을 이용하여 프로바이더를 모킹한 스텁을 구성할 수 있어서 컨슈머만으로 통합 테스트를 작성
    - 프로바이더 쪽 테스트 : 프로바이더의 어댑터에 대한 테스트. 어댑터의 디펜던시를 목으로 잡아 놓고 계약을 이용하여 어댑터 테스트

### 10.1.1 통합 테스트: 영속화
- 영속화 통합 테스트의 절차
  - 설정(setup) : DB 스키마를 생성하고 기지의 상태로 초기화하는 DB를 설정
  - 실행(execute) : DB 작업을 수행
  - 확인(verify) : DB 상태, 그리고 DB에서 조회한 객체를 단언
  - 정리(teardown) : 설정 단계에서 시작한 트랜잭션을 롤백하는 등 DB에 변경한 내용을 언두해야 할 경우 사용 

- DB 프로비저닝을 어떻게 할까?
 - 도커를 활용

- DBUnit 이용

### 10.1.2 통합 테스트: REST 요청/응답형 상호 작용
- 스프링 클라우드 컨트랙트를 이용해서 REST 기반의 상호 작용을 테스트

- 소비자쪽 API 게이트웨이 통합 테스트는 계약을 이용하여 주문 서비스의 동작을 흉내낸 HTTP 스텁 서버를 구성
- 계약의 요청은 API 게이트웨이가 스텁에 어떤 HTTP 요청을 하는지 기술하고, 계약의 응답은 스텁이 API 게이트웨이에 어떤 응답을 돌려주는지 기술

#### REST API 계약 예제
```
org.springframework.cloud.contract.spec.Contract.make {
  request {
    method 'GET'
    url '/orders/1223232'

  }
  response {
    status 200

    headers {
      header('Content-Type': 'application/json;charset=UTF-8')
    }
    body('''{"orderId" : "1223232", "state" : "APPROVAL_PENDING"}''')
}
```
- 계약 요청에는 HTTP 메서드 경로, 헤더(옵션)
- 계약 응답에는 HTTP 상태 코드, 헤더(옵션), 본문(해당 시)

#### 컨슈머 주도 계약 통합 테스트: 주문 서비스
- 스프링 클라우드 컨트랙트로 코드-생성된 테스트 클래스의 추상 기초 클래스 HttpBase는 테스트 설정 단계를 담당
 - 이 클래스는 목 디펜던시가 주입된 컨트롤러를 생성하고, 이 목이 컨트롤러가 기대한 응답을 만들어 내도록 설정

#### 소비자 쪽 통합 테스트: API 게이트웨이의 OrderServiceProxy
- 10-4 예제에서 `@AutoConfigureStubRunnder`는 스프릥 클라우드 컨트랙트가 랜덤 포트에 와이어목 서버를 계약 내용대로 구성/실행하도록 지시하는 애너테이션
- 각 테스트 메서드는 OrderServiceProxy를 호출해서 정확한 값이 반환되는지, 아니면 기대한 예외가 던져지는지 확인

### 10.1.3 통합 테스트: 발행/구독 스타일 상호 작용
- 상호 작용은 계약 세트로 정의하는 것은 같지만, 각 계약마다 도메인 이벤트를 지정하는 차이점이 있음

- 컨슈머 쪽 테스트는 각 계약에 지정된 이벤트를 발행하며 OrderHistoryEventHandler가 목 디펜던시를 올바르게 호출하는지 확인
- 프로바이더 쪽은 스프링 클라우드 컨트랙트가 MessagingBase를 상속한 테스트 클래스를 코드-생성함
  - 각 테스트 메서드가 MessagingBase에 있는 훅 메서드를 호출하면 서비스에 의해 이벤트 발행이 트리거됨 

#### OrderCreated 이벤트 발행 계약
- 예제 10-5 계약의 두 가지 주요 엘리먼트
  - label : 컨슈머 테스트에서 스프링 컨트랙트가 이벤트 발행을 트리거하기 위해 사용하는 엘리먼트
  - triggeredBy : 코드-생성된 테스트 메서드가 이벤트 발행을 트리거하기 위해 호출하는 상위 클래스의 메서드명

#### 컨슈머 주도 계약 테스트: 주문 서비스
- 주문 서비스의 프로바이더 쪽 테스트는 컨슈머 주도 계약 통합 테스트

#### 소비자 쪽 계약 테스트: 주문 이력 서비스
- 주문 이력 서비스는 주문 서비스가 발행한 이벤트를 소비하는 서비스

### 10.1.4 통합 계약 테스트: 비동기 요청/응답 상호 작용
- 비동기 요청/응답 상호 작용에는 커맨드를 전송하는 서비스인 요청자(requestor), 커맨드 처리 후 응답을 반환하는 서비스인 응답자(replier)가 있음
- 요청자와 응답자가 바라보는 커맨드 메시지 채널명과 커맨드/응답 메시지의 구조는 반드시 일치해야 함

- 비동기 요청/응답 상호 작용의 통합 테스트는 REST 테스트와 비슷하며, 요청/응답 대신 입출력 메시지를 지정하는 것만 다름

- 스프링 클라우드 컨트랙트는 프로바이더 쪽 테스트를 코드-생성함
  - 각 테스트 메서드는 하나의 계약에 대응되며, 계약의 입력 메시지를 커맨드 메시지로 전송하고 그 응답 메시지가 계약의 출력 메시지와 일치하는지 테스 

#### 비동기 요청/응답 계약 예제
- 입출력 메시지 모두 메시지 채널, 본문, 헤더가 지정되어 있고, 프로바이더 관점에서 명명 규칙을 따랐음

#### 소비자 쪽 계약 통합 테스트: 비동기 요청/응답 상호 작용
- 테스트는 서비스의 메시징 프록시를 호출해서 메시징 프록시가 계약대로 커맨드 메시지를 보내는지, 그리고 프록시가 응답 메시지를 적절히 처리하는지, 두 가지를 확인

#### 프로바이더 쪽, 컨슈머 주도 계약 테스트: 비동기 요청/응답 상호 작용
- 프로바이더 쪽 통합 테스트는 프로바이더가 응답을 올바르게 전송해서 커맨드 메시지를 처리하는지 확인해야 함

## 10.2 컴포넌트 테스트 개발
- 컴포넌트 테스트는 모든 디펜던시를 각자의 동작을 모킹한 스텁으로 대체하고, 서비스를 따로 분리하여 그 동작을 확인함

### 10.2.1 인수 테스트 정의
- 인수 테스트는 소프트웨어 컴포넌트의 비즈니스와 연관된 테스트
- 사용자 스토리나 유스 케이스에서 출발하며, 내부 구현이 아닌 컴포넌트의 클라이언트 관점에서 어떤 동작이 외부에 드러나야 하는지 기술

- 시나리오마다 하나의 인수 테스트가 도출
  - given(~라면)은 설정 단계(setup phase)
  - when(~경우)은 실행 단계(execute phase)
  - then(~되어야 한다)과 and(그리고)는 확인 단계(verification phase)

### 10.2.2 인수 테스트 작성: 거킨
- 커킨은 실행 가능한 명세를 작성하는 DSL
- 일상 언어로 작성한 시나리오 형태로 인수 테스트를 정의한 후, 큐 컴버라는 거킨 전용 테스트 자동화 프레임워크를 이용하여 명세를 실행

#### 큐컴버를 이용한 커킨 명세 실행
- 큐컴버는 거킨으로 작성한 테스트를 실행하는 자동화 테스트 프레임워크
- 큐컴버 사용 시, 스텝 데피니션 클래스를 작성
  - given(설정 단계), then(실행 단계), when, and(확인 단계) 각 스텝의 의미를 정의한 메서드로 구성

### 10.2.3 컴포넌트 테스트 설계

#### 인-프로세스 컴포넌트 테스트
- 이 테스트는 인-메모리 스텁과 목 디펜던시로 서비스를 실행
  - ex) `@SpringBootTest`

#### 아웃-오브-프로세스 컴포넌트 테스트
- 이 테스트는 DB, 메시지 브로커 등은 실제 인프라 서비스를 사용하고, 애플리케이션 서비스 형태의 디펜던시는 스텁으로 대신함
  - ex) 주문 서비스의 MySQL, 카프카는 진짜 인프라 사용, 소비자/회계 서비스 등은 스텁 

#### 아웃-오브-프로세스 컴포넌트 테스트에서 서비스를 스터빙하는 방법
- 이해 안감

### 10.2.4 컴포넌트 테스트 작성: 주문 서비스
```
@RunWith(Cucumber.class)
@CucumberOptions(features = "src/component-test/resources/features")
public class OrderServiceComponentTest {
}
```
- `@CucumberOptions` 에는 거킨 피처 파일 경로 지정
- `@RunWith(Cucumber.class)` 는 JUnit에 큐컴버 테스트 러너를 사용하라 지시


#### 컴포넌트 테스트 실행
- 도커 컴포즈를 사용해서 테스트에 필요한 인프라 구성

## 10.3 종단 간 테스트 작성
- 종단 간 테스트는 애플리케이션 전부 테스트
  - 느리고, 취약하고, 개발 소요 시간이 김

### 10.3.1 종단 간 테스트 설계
- 사용자 탐험 테스트는 사용자가 시스템을 돌아다니면서 여기저기 둘러보는 행위를 코드로 구현

### 10.3.2 종단 간 테스트 작성
- 종단 간 테스트도 거킨으로 테스트를 작성해서 큐컴버로 실행할 수 있음 (대신 아주 많은 액션이 테스트에 담겨 있음)

### 10.3.3 종단 간 테스트 실행
- 종단 간 테스트를 실행하려면 필수 인프라 서비스 등 전체 애플리케이션을 실행해야 함
  - 도커 컴포즈 플러그인 사용 
